{{meta {load_files: ["code/journal.js", "code/chapter/04_data.js"], zip: "node/html"}}}

# ساختارهای داده: اشیاء و آرایه‌ها

{{quote {author: "Charles Babbage", title: "Passages from the Life of a Philosopher (1864)", chapter: true}

On two occasions I have been asked, 'Pray, Mr. Babbage, if you put
into the machine wrong figures, will the right answers come out?'
[...] I am not able rightly to apprehend the kind of confusion of
ideas that could provoke such a question.

quote}}

{{index "Babbage, Charles"}}

{{figure {url: "img/chapter_picture_4.jpg", alt: "Picture of a weresquirrel", chapter: framed}}}

{{index object, "data structure"}}

اعداد، مقادیر بولی، و رشته‌ها عناصری هستند که ساختار داده‌‌ها از آن ها ساخته می شوند. اگرچه انواع زیادی از اطلاعات هستند که نیاز به چیزی بیش از یک عنصر دارند. _اشیاء_ این امکان را به ما می دهند که مقادیر مختلف – از جمله دیگر اشیاء – را با هم ترکیب کنیم و ساختارهای پیچیده‌تری را بسازیم.

برنامه هایی که تا کنون ساخته‌ایم محدود به کار با انواع داده‌ی ساده بوده اند. این فصل ساختارهای داده‌ی پایه معرفی می شوند. در انتهای این فصل ، به اندازه کافی اطلاعات دارید که شروع به نوشتن برنامه‌های کاربردی بکنید.

این فصل با مثال‌های برنامه‌نویسی کم و بیش واقعی جلو می رود تا مفاهیم جدید را همانطور که در مسئله پیش می آیند، معرفی کند. کدهای مثال‌ها اغلب با توابع و متغیرهایی که پیش‌تر معرفی شده اند ساخته می شوند.

{{if book

محیط تست که به صورت آنلاین برای کدها این کتاب در نظر گرفته شده است ([_https://eloquentjavascript.net/code_](https://eloquentjavascript.net/code)) این امکان را فراهم کرده است که کدهای هر فصل را اجرا کنید. اگر تصمیم دارید تا مثال‌ها را در محیط دیگری اجرا کنید، مطمئن شوید که ابتدا کل کدها را از سایت دانلود کنید.

if}}

## انسان‌سنجاب

{{index "weresquirrel example", lycanthropy}}
هر از چند گاهی معمولا بین ساعت هشت تا ده شب ((ژاک)) متوجه می شود که تغییر شکل داده و به یک جونده کوچک با دمی پرپشت تبدیل می شود.

از یک سو ژاک نسبتا خوشحال است که شبیه داستان‌های کلاسیک تبدیل به گرگ نمی شود. سنجاب شدن احتمالا مشکلاتی کمتری نسبت به گرگ شدن ایجاد می کند. به جای اینکه نگران باشد که اتفاقی همسایه‌اش را نخورد ( که خیلی ناجور است )، نگران خورده شدن توسط گربه‌ی همسایه است. بعد از دو مرتبه‌ای که روی شاخه‌ی باریک و لرزانی بالای یک درخت بلوط، لخت و گیج، بیدار شد، درها و پنجره‌های  اتاقش را شب‌ها قفل می کرد و چندتایی گردو هم کف اتاق قرار می داد که سرگرم بماند.

این، مشکل گربه‌ی همسایه و درخت را حل می کرد. اما ژاک به دنبال این بود که از این مشکل به طور کلی رهایی یابد. تبدیل شدن‌های بی نظم و قاعده باعث شده بود که شک کند شاید چیز خاصی علت این مشکل باشد. برای مدتی،  فکر می کرد که این اتفاق در روزهایی رخ می دهد که نزدیک درخت بلوط بوده است. اما دوری از درخت بلوط هم کمکی نکرد و مشکل برطرف نشد.

{{index journal}}

ژاک با انتخاب روشی علمی تر، اقدام به نگه‌داری گزارشی روزانه از همه‌ی فعالیت‌هایی یک روز و وضعیت تبدیل شدن به سنجاب نموده است. با در دست داشتن این اطلاعات، امیدوار است بتواند شرایطی که باعث بروز تبدیل می شود را محدودتر کند.

اکنون اولین کاری که باید انجام دهد طراحی یک ساختار داده برای ذخیره این اطلاعات است.

## مجموعه‌های داده

{{index ["data structure", collection], [memory, organization]}}

برای کار با داده‌های دیجیتال، ابتدا باید راهی، برای
ارائه‌ی آن‌ها در حافظه‌ی کامپیوتر (ماشین) بیابیم. به عنوان یک مثال ساده، فرض کنید که می خواهیم ((مجموعه)) ای از اعداد، 2، 3، 5، 7، و 11 را در حافظه قرار دهیم.

{{index string}}

برای این کار می توانیم از رشته‌ها، خلاقانه بهره ببریم – به هر حال رشته ها می توانند هر طولی داشته باشند؛ پس می توان داده‌های زیادی درون آن‌ها قرار داد – و از نمایش رشته‌ای <bdo>`"2 3 5 7 11"`</bdo> استفاده کنیم. اما این کار ایرادهایی دارد. برای استفاده از اعداد، مجبور خواهید شد که به شکلی آن ها را از دل رشته ها استخراج و به نوع عدد تبدیل کنید.

{{index [array, creation], "[] (array)"}}

خوشبختانه، جاوااسکریپت نوع داده‌ای فراهم می کند که به طور خاص برای ذخیره دنباله‌ای از مقدارها استفاده می شود. این نوع داده خاص _آرایه_ نام دارد و به این صورت نوشته می شود که مقدارها بین براکت قرار می گیرند و با ویرگول جدا می شوند.

```
let listOfNumbers = [2, 3, 5, 7, 11];
console.log(listOfNumbers[2]);
// → 5
console.log(listOfNumbers[0]);
// → 2
console.log(listOfNumbers[2 - 1]);
// → 3
```

{{index "[] (subscript)", [array, indexing]}}

برای دستیابی به عناصر درون یک آرایه نیز، از براکت‌ها استفاده می شود. یک جفت براکت که بلافاصله بعد از یک عبارت می آیند و بعد از آن عبارتی دیگر درون آن قرار می گیرد. با این کار عنصر مورد نظرمان را با استفاده از _شاخصی_ که به وسیله عبارت داخل براکت‌ها مشخص می کنیم، در داخل عبارت سمت چپ جستجو می کنیم.

{{id array_indexing}}
{{index "zero-based counting"}}

اولین خانه‌ی یک آرایه، صفر است، نه یک. بنابراین اولین عنصر را می توان با <bdo>`listOfNumbers[0]`</bdo> به دست آورد.  شمارش از صفر، در تکنولوژی سابقه‌ای دیرینه دارد و در بعضی مواقع کاری بسیار معقول می باشد؛ اما ممکن است کمی زمان ببرد تا به آن عادت کنید. می توانید اندیس آرایه را به صورت تعداد آیتم هایی که باید از ابتدای آرایه گذشت تا به عنصر مورد نظر رسید، تصور کرد.

{{id properties}}

## خاصیت‌ها

{{index "Math object", "Math.max function", ["length property", "for string"], [object, property], "period character", [property, access]}}

در فصل‌های قبل، با عبارت‌هایی روبرو شده ایم که ظاهری نامانوس داشتند مانند <bdo>`myString.length`</bdo> (برای بدست آوردن طول رشته) یا `Math.max` (برای یافتن بیشینه اعداد). این ها عبارت‌هایی هستند که به _خاصیتی_ از یک مقدار دسترسی دارند. در مثال اول، به خاصیت `length` از مقدار `myString` اشاره می کنیم. در مورد دوم، به خاصیتی با نام `max` از شیء `Math` دسترسی پیدا کرده ایم ( که این شیء شامل مجموعه ای از ثابت ها و توابع ریاضی می باشد).

{{index [property, access], null, undefined}}

تقریبا همه‌ی مقدارهای جاوااسکریپت دارای خاصیت‌ها می باشند. مورد استثنا `null` و `undefined`  است. اگر سعی کنید تا به خاصیتی از این دو اشاره کنید، با خطا مواجه خواهید شد.

```{test: no}
null.length;
// → TypeError: null has no properties
```

{{indexsee "dot character", "period character"}}
{{index "[] (subscript)", "period character", "square brackets", "computed property", [property, access]}}

دو روش رایج برای دسترسی به خاصیت‌ها در جاوااسکریپت استفاده از نقطه و براکت است. هر دوی <bdo>`value.x`</bdo> و <bdo>`value[x]`</bdo> به خاصیتی از `value` دسترسی دارند – اما نه لزوما به خاصیتی یکسان. تفاوت به نحوه‌ی تفسیر `x` بر می گردد. زمانی که از نقطه استفاده می کنیم، قسمت بعد از نقطه، بایستی نام متغیری معتبر باشد که مستقیما نام خاصیت را مشخص می کند. زمانی که از براکت استفاده می شود، عبارتی که بین براکت‌ها قرار می گیرد _ارزیابی_ شده تا نام خاصیت مشخص شود. در حالیکه  <bdo>`value.x`</bdo> خاصیتی از `value` که نام آن "x" است را برمی‌گرداند، <bdo>`value[x]`</bdo> سعی می کند تا عبارت `x` را ارزیابی کرده و نتیجه‌ی آن را به عنوان نام خاصیت استفاده کند.

بنابراین اگر می دانید که نام خاصیتی که مورد نظرتان است _color_ است شود به سراغ <bdo>`value.color`</bdo> بروید. اگر قصد دارید به خاصیتی اشاره کنید که نامش در متغیر `i` ذخیره شده است ، می توانید از <bdo>`value[i]`</bdo> استفاده کنید. نام یک خاصیت می تواند هر رشته‌ای باشد، اما روش استفاده از نقطه، فقط روی نام‌هایی کار می کند که برای یک متغیر معتبر می باشند. بنابراین اگر قصد دارید تا به خاصیتی به نام _2_ یا <bdo>_John Doe_</bdo> دسترسی داشته باشید، باید حتما از براکتها استفاده کنید:‌<bdo>`value[2]`</bdo>  یا <bdo>`value["John Doe"]`</bdo>.

عناصر درون یک ((آرایه)) به عنوان خاصیت‌های آن ذخیره می شوند که برای نام این خاصیت ها از اعداد استفاده می شود. چون نمی توان از نقطه برای دسترسی به نام‌های عدد استفاده کرد، و اغلب لازم است تا به خانه‌های آرایه با استفاده از متغیرها اشاره کنیم، باید از روش براکت‌ برای دستیابی به آن‌ها استفاده کنیم.

{{index ["length property", "for array"], [array, "length of"]}}

خاصیت `length` در آرایه‌ها هم تعداد عناصری که در آرایه وجود دارد را نشان می دهد. نام این خاصیت (length)، نامی معتبر برای یک متغیر می باشد و ما از آن آگاه بودیم پس به سراغ روش <bdo>`array.length`</bdo> می رویم چراکه از <bdo>`array["length"]`</bdo> آسان تر نوشته می شود.

{{id methods}}

## متدها

{{index [function, "as property"], method, string}}

هر دوی اشیاء رشته‌ای و آرایه‌ای، علاوه بر خاصیت `length` تعدادی خاصیت دیگر دارند که که حاوی مقدارهایی از جنس تابع هستند.

```
let doh = "Doh";
console.log(typeof doh.toUpperCase);
// → function
console.log(doh.toUpperCase());
// → DOH
```

{{index "case conversion", "toUpperCase method", "toLowerCase method"}}

همه‌ی رشته‌ها خاصیت `toUpperCase` را دارند که در صورت فراخوانی، یک کپی از رشته‌ را با حروف بزرگ برمی‌گرداند. همچنین `toLowerCase` نیز وجود دارد که عکس آن عمل می کند.

{{index "this binding"}}

جالب آن‌که، وقتی که `toUpperCase` فراخوانی می شود علی رغم اینکه مقداری به عنوان آرگومان دریافت نمی کند، این تابع به نحوی به رشته‌ی `"Doh"` دسترسی دارد (مقداری که خاصیت را روی آن فراخوانی کرده ایم). چگونگی کارکرد این موضوع در [فصل ?](object#obj_methods) توضیح داده می شود.

خاصیت‌هایی که حاوی تابع هستند را عموما _متدهای_ مقداری که به آن تعلق دارند، می نامند. همانطور که `toUpperCase` متدی از یک رشته محسوب می شود.

{{id array_methods}}

مثال پیش رو، دو متد را که می توانید از آن ها برای دستکاری آرایه‌ها استفاده کنید، شرح می دهد:

```
let sequence = [1, 2, 3];
sequence.push(4);
sequence.push(5);
console.log(sequence);
// → [1, 2, 3, 4, 5]
console.log(sequence.pop());
// → 5
console.log(sequence);
// → [1, 2, 3, 4]
```

{{index collection, array, "push method", "pop method"}}

متد `push` را میتوان برای افزودن مقادیر به انتهای یک آرایه استفاده کرد. متد `pop` عکس آن عمل می کند: آخرین مقداری که در انتهای یک آرایه وجود دارد را حذف کرده و برمی گرداند.

{{index ["data structure", stack]}}

نام این دو متد در کارهای مرتبط با پشته‌ها از قدیم استفاده می شده است. یک _((پشته‌))_، در برنامه نویسی، ساختار داده‌ای است که این امکان را به شما می دهد تا مقادیر را به آن وارد کرده و به ترتیب عکس از آن خارج نمایید. بنابراین مقداری که آخر از همه وارد شده است، اول از همه خارج می شود. این کارها در برنامه نویسی رایج هستند – ممکن است پشته‌ی فراخوانی توابع که در [فصل قبل](functions#stack) بحث شد را به خاطر بیاورید که نمونه ای از همین مفهوم است.

## آبجکت‌ها یا اشیاء

{{index journal, "weresquirrel example", array, record}}

برگردیم به مثال انسان‌سنجاب.  می توان مجموعه‌ای از گزارشات روزانه را به صورت یک آرایه نشان داد. اما گزارشات فقط شامل رشته یا عدد نیستند – هر گزارش باید لیستی از فعالیت‌ها به همراه یک مقدار بولی که نشان می می دهد ژاک به سنجاب تبدیل شده است یا خیر را ذخیره کند. در حالت ایده‌آل، دوست داشتیم که این اطلاعات را با هم گروه کرده و یک مقدار بسازیم و آن مقادیر گروه شده را در یک آرایه‌ای از گزارشات ذخیره کنیم.


{{index [syntax, object], [property, definition], [braces, object], "{} (object)"}}

مقادیری که از نوع _((object))_ هستند دارای مجموعه‌ای از خاصیت‌های دلخواه هستند . یک راه برای ایجاد یک شیء استفاده از کروشه ها به عنوان یک عبارت است.

```
let day1 = {
  squirrel: false,
  events: ["work", "touched tree", "pizza", "running"]
};
console.log(day1.squirrel);
// → false
console.log(day1.wolf);
// → undefined
day1.wolf = false;
console.log(day1.wolf);
// → false
```

{{index [quoting, "of object properties"], "colon character"}}

درون کروشه ها، می توانیم لیستی از خاصیت‌ها را که با ویرگول جدا می شوند را تعریف کنیم. هر خاصیت به وسیله‌ی یک نام، یک کاراکتر دونقطه در جلوی‌ آن و یک عبارت که مقدار خاصیت را مشخص می کند تعریف می شود. زمانی که تعریف یک شیء به چند خط می کشد،‌ استفاده از تورفتگی در کد‌ها باعث افزایش خوانایی می شود. خاصیت‌هایی که نامشان نام معتبری برای یک متغیر محسوب نمی شوند یا اعداد می بایست درون نقل قول قرار بگیرند.

```
let descriptions = {
  work: "Went to work",
  "touched tree": "Touched a tree"
};
```

{{index [braces, object]}}

این بدین معناست که کروشه‌ها در جاوااسکریپت _دو_ معنای متفاوت دارند. در شروع یک ((دستور))، نشانگر شروع یک ((بلاک)) از دستورات هستند. در دیگر مکان‌ها، نمایانگر تعریف یک شیء می باشند. خوشبختانه، به ندرت کاربردی برای شروع یک دستور با یک شیء درون کروشه‌ها پیدا می شود، بنابراین ابهام بین این دو، مسئله‌ای ایجاد نمی کند.

{{index undefined}}

خواندن خاصیتی که وجود نداشته باشد باعث تولید مقدار `undefined` می شود.

{{index [property, assignment], mutability, "= operator"}}

می توان مقداری را به خاصیتی به وسیله عملگر `=` اختصاص داد. این کار باعث می شود مقدار خاصیت مورد نظر – در صورت وجود – جایگزین شده یا در غیر این صورت خاصیت جدید در شیء به وجود بیاید.


{{index "tentacle (analogy)", [property, "model of"], [binding, "model of"]}}

استعاره‌ی بازوچه که برای متغیرها استفاده شد در اینجا هم کاربرد دارد. خاصیت‌ها به مقدارها _چنگ می زنند_ و این مقدارها ممکن است توسط دیگر متغیرها و خاصیت ها هم نگه داری شوند.  می توانید اشیاء را اختاپوسی در نظر بگیرید که بازوهای متعددی دارد که هر کدام از آن ها نامی دارد که روی آن حک شده است.

{{index "delete operator", [property, deletion]}}

عملگر `delete` باعث قطع یک بازوچه از این اختاپوس می شود. این عملگر، یکانی است و اگر به خاصیتی اعمال شود، خاصیت نام‌برده را از شیء حذف می کند. استفاده از این عملگر زیاد رایج نیست، اما به هر حال قابل استفاده است.

```
let anObject = {left: 1, right: 2};
console.log(anObject.left);
// → 1
delete anObject.left;
console.log(anObject.left);
// → undefined
console.log("left" in anObject);
// → false
console.log("right" in anObject);
// → true
```

{{index "in operator", [property, "testing for"], object}}

عملگر دودویی `in` اگر به رشته‌ای یا شیءای اعمال شود، مقداری از جنس بولی بر می گرداند که مشخص می کند که آن شیء دارای آن خاصیت است یا خیر. تفاوت بین اختصاص `undefined` به یک خاصیت و حذف آن این است که در مورد اول، شیء مورد بحث همچنان آن خاصیت را دارد (اگرچه مقدار به درد بخوری ندارد) در حالیکه در مورد دوم خاصیت دیگر وجود ندارد و عملگر `in` مقدار `false` را بر می گرداند.


{{index "Object.keys function"}}

برای بدست آوردن خاصیت‌های یک شیء، می توانید از تابع <bdo>`Object.keys`</bdo> استفاده کنید. اگر شیءای را به آن بدهید، آرایه‌ای از نام خاصیت‌های شیء بر می گرداند.

```
console.log(Object.keys({x: 0, y: 0, z: 2}));
// → ["x", "y", "z"]
```
تابع دیگری به نام <bdo>`Object.assign`</bdo> نیز وجوددارد که تمام خاصیت‌های یک شیء را در شیء دیگری کپی می کند.

```
let objectA = {a: 1, b: 2};
Object.assign(objectA, {b: 3, c: 4});
console.log(objectA);
// → {a: 1, b: 3, c: 4}
```

{{index array, collection}}

آرایه‌ها نیز، در واقع شکل خاصی از اشیاء هستند که برای ذخیره‌ی دنباله‌ای از چیزها اختصاصی شده اند. اگر <bdo>`typeof []`</bdo>  را ارزیابی کنید، مقدار `"object"` تولید می شود. می توانید آن ها را به عنوان اختاپوس‌های درازی در نظر بگیرید که همه‌ی بازوهای آن‌ها به شکل ردیفی مرتب با اعداد برچسب گذاری شده اند.

{{index journal, "weresquirrel example"}}

بنابراین می توانیم دفترچه‌ی ژاک را به صورت آرایه ای از اشیاء نمایش دهیم.

```{test: wrap}
let journal = [
  {events: ["work", "touched tree", "pizza",
            "running", "television"],
   squirrel: false},
  {events: ["work", "ice cream", "cauliflower",
            "lasagna", "touched tree", "brushed teeth"],
   squirrel: false},
  {events: ["weekend", "cycling", "break", "peanuts",
            "beer"],
   squirrel: true},
  /* and so on... */
];
```

## تغییر پذیری

به زودی به برنامه‌نویسی _واقعی_ می رسیم. قبل از آن یک قسمت تئوری دیگر وجود دارد که باید درک شود.

{{index mutability, "side effect", number, string, Boolean, [object, mutability]}}

تا حالا متوجه‌ شده‌ایم که مقدار اشیاء را می توان تغییر داد. انواع مقدارهایی که در فصلهای پیشین بحث کردیم، مانند اعداد، رشته‌ها و مقادیر بولی،‌ همه _((غیرقابل تغییر))_ بودند. تغییر مقداری از این انواع داده غیر ممکن است. می توانید آن‌ها را ترکیب کنید تا مقادیر جدیدی ایجاد کنید اما اگر مقدار رشته‌ای خاصی را بگیرید، مقدارش همیشه همان خواهد ماند. متن داخلش را نمی توان عوض کرد. اگر رشته‌ای داشته باشید که مقدار `"cat"` را دربردارد، برای کدهای برنامه امکان ندارد که بتوانند یک کاراکتر از آن را تغییر دهند و مثلا به `"rat"` تبدیلش کنند.

محتوای یک مقدار از نوع شیء را _می توان_ به وسیله‌ی خاصیت‌هایش تغییر داد.
این کار باعث می شود که یک شیء در زمان‌های مختلف محتوای متفاوتی داشته باشد.

{{index [object, identity], identity, [memory, organization], mutability}}

زمانی که دو عدد مثلا 120 و 120 را داریم می توانیم هر دو را دقیقا یک عدد مشابه در نظر بگیریم، فارغ از اینکه به بیت‌های فیزیکی یکسانی مربوط باشند یا خیر. اما در اشیاء، بین داشتن دو ارجاع به یک شیء یکسان و داشتن دو شیء متفاوت که خاصیت‌های مشابهی دارند،‌تفاوت وجود دارد. به کدهای زیر رو توجه کنید:

```
let object1 = {value: 10};
let object2 = object1;
let object3 = {value: 10};

console.log(object1 == object2);
// → true
console.log(object1 == object3);
// → false

object1.value = 15;
console.log(object2.value);
// → 15
console.log(object3.value);
// → 10
```

{{index "tentacle (analogy)", [binding, "model of"]}}

متغیرهای `object1` و `object2` به شیء مشابهی اشاره می کنند که به همین دلیل تغییر `object1` منجر به تغییر مقدار `object2` هم می شود. گفته می شود این دو هویت یکسانی دارند. متغیر `object3` به شی دیگری اشاره می کند که دارای خاصیت هایی مشابه `object1` است اما در فضای متفاوتی قرار گرفته است.

{{index "const keyword", "let keyword", [binding, "as state"]}}

متغیرها نیز می توانند از نوع ثابت و غیر ثابت باشند، اما این قضیه ارتباطی به رفتار مقدارهای آن ها ندارد. اگرچه مقداری از جنس عدد تغییر ناپذیر است، می توانید از متغیر که با `let` تعریف شده است استفاده کنید تا عددی که متغیر به آن اشاره می کند را عوض کنید. به طور مشابه، اگرچه یک ثابت که با `const` برای یک شیء تعریف شده است را نمی توان تغییر داد و همیشه به شیء مشابهی اشاره خواهد کرد، اما _محتوای_ آن شیء قابل تغییر است.


```{test: no}
const score = {visitors: 0, home: 0};
// This is okay
score.visitors = 1;
// This isn't allowed
score = {visitors: 1, home: 1};
```

{{index "== operator", [comparison, "of objects"], "deep comparison"}}

عملگر `==` جاوااسکریپت، وقتی برای مقایسه‌ی اشیاء استفاده می شود، تنها زمانی مقدار `true` را برمی گرداند که هر دو شیء دقیقا مقدار یکسانی باشند. مقایسه اشیاء متفاوت حتی زمانی که محتوای آن ها یکسان باشد باعث برگرداندن `false` می شود. در جاوااسکریپت عملگری برای مقایسه‌ی عمیق تعبیه نشده است که محتوای اشیاء را بررسی و مقایسه کند. اما خودتان می توانید آن را بنویسید ( یکی از [تمرین‌های](data#exercise_deep_compare) پایان این فصل همین مساله خواهد بود).

## برنامه‌ی گزارش مسخ

{{index "weresquirrel example", lycanthropy, "addEntry function"}}

خوب ژاک برنامه مفسر جاوااسکریپت را اجرا می کند و محیطی که برای نوشتن گزارش روزانه نیاز دارد را فراهم می کند

```{includeCode: true}
let journal = [];

function addEntry(events, squirrel) {
  journal.push({events, squirrel});
}
```

{{index [braces, object], "{} (object)", [property, definition]}}

توجه کنید که آبجکتی که به ژورنال اضافه می شود کمی غیر عادی به نظر می رسد. به جای اینکه خاصیت را به شکل `events: events` بنویسیم، فقط نام خاصیت نوشته شده است. این دستور کوتاه معادل همان روش معمولی است – اگر در روش تعریف شیء به وسیله کروشه‌ها، نام خاصیتی بدون تعریف مقدارش نوشته شود، مقدار آن از متغیری با همان نام گرفته می شود.

بنابراین هر شب ساعت ده – یا گاهی اوقات صبح روز بعد، بعد از پایین آمدن از قفسه بالایی کتابخانه اش-  ژاک گزارش روز را ثبت می کند.

```
addEntry(["work", "touched tree", "pizza", "running",
          "television"], false);
addEntry(["work", "ice cream", "cauliflower", "lasagna",
          "touched tree", "brushed teeth"], false);
addEntry(["weekend", "cycling", "break", "peanuts",
          "beer"], true);
```

زمانی که مقدار کافی اطلاعات در دست داشت، قصد دارد تا به محاسبه‌ی ارتباط بین تبدیل شدنش به سنجاب و اتفاقاتی که در آن روز افتاده است بپردازد و امیدوار است چیزهای مفیدی از این همبستگی‌ها دستش بیاید.

{{index correlation}}

_همبستگی_ مقیاسی برای تعیین میزان _وابستگی_ بین متغیرهای آماری است. یک متغیر آماری شبیه به متغیرها در زبان‌های برنامه نویسی نیست. در آمار، شما معمولا مجموعه‌ای از سنجش‌ها را در اختیار دارید و هر متغیر با همه‌ی سنجش‌ها اندازه‌گیری می شود. همبستگی بین متغیرها معمولا به شکل ضریبی بین <bdo>-1</bdo> تا <bdo>1</bdo> تولید می شود. ضریب همبستگی صفر به معنای این است که دو متغیر هیچ ارتباطی با هم ندارند و ضریب همبستگی یک به معنای ارتباط کامل دو متغیر است – اگر یکی از آن ها را بدانید، دیگری را نیز می توانید بدست بیاورید. منفی یک نیز به معنای ارتباط کامل دو متغیر اما به شکل معکوس و مخالف است- زمانی که یکی درست است دیگری نادرست خواهد بود.

{{index "phi coefficient"}}

برای محاسبه اندازه ضریب همبستگی بین دو متغیر بولی، می توانیم از _ضریب فی_ (_ϕ_) استفاده کنیم. این ضریب فرمولی است که ورودی آن یک جدول فراوانی از تعداد دفعاتی است که ترکیب های مختلف دو متغیر مشاهده شده اند. خروجی فرمول،  عددی بین <bdo>-1</bdo> و 1 است که میزان همبستگی را مشخص می کند.

می توانیم رخداد خوردن ((پیتزا)) را در نظر بگیریم و آن را در جدول فراوانی به شکل زیر قرار دهیم، جایی که هر عدد نمایانگر تعداد دفعاتی است که ترکیب مورد نظر ما اتفاق افتاده است:

{{figure {url: "img/pizza-squirrel.svg", alt: "Eating pizza versus turning into a squirrel", width: "7cm"}}}

اگر جدول را _n_ بنامیم، می توان _ϕ_ را با فرمول زیر محاسبه کرد:

{{if html

<div>
<table style="border-collapse: collapse; margin-right: 1em;"><tr>
  <td style="vertical-align: middle"><em>ϕ</em> =</td>
  <td style="padding-right: .5em">
    <div style="border-bottom: 1px solid black; padding: 0 7px;"><em>n</em><sub>11</sub><em>n</em><sub>00</sub> −
      <em>n</em><sub>10</sub><em>n</em><sub>01</sub></div>
    <div style="padding: 0 7px;">√<span style="border-top: 1px solid black; position: relative; top: 2px;">
      <span style="position: relative; top: -4px"><em>n</em><sub>1•</sub><em>n</em><sub>0•</sub><em>n</em><sub>•1</sub><em>n</em><sub>•0</sub></span>
    </span></div>
  </td>
</tr></table>
</div>

if}}

{{if tex

[\begin{equation}\varphi = \frac{n_{11}n_{00}-n_{10}n_{01}}{\sqrt{n_{1\bullet}n_{0\bullet}n_{\bullet1}n_{\bullet0}}}\end{equation}]{latex}

if}}

( اگر دارید کتاب را می بندید تا به سراغ خاطرات وحشتناک کتاب ریاضی دبیرستان بروید، صبر کنید! قرار نیست که در این کتاب شما را با فرمول‌های عجیب و غریب اذیت کنم – فعلا همین یک فرمول بس است. برای همین یک مورد هم تمام کاری که قرار است بکنیم تبدیل آن به جاوااسکریپت است.)

نماد <bdo>[_n_~01~]{if html}[[$n_{01}$]{latex}]{if tex}</bdo> نشان دهنده‌ی تعداد اندازه‌گیری‌هایی است که اولین متغیر (سنجاب شدن) برابر false یا 0 و دومین اندازه‌گیری (پیتزا خوردن) <bdo>true (1)</bdo> شده است. در این مثال <bdo>[_n_~01~]{if html}[[$n_{01}$]{latex}]{if tex}</bdo> برابر 9 است.

مقدار <bdo>[_n_~1•~]{if html}[[$n_{1\bullet}$]{latex}]{if tex}</bdo> برابر با جمع همه اندازه‌گیری‌هایی است که متغیر اول آن ها true ارزیابی شده است که در این مثال 5 است. به همین صورت <bdo>[_n_~•0~]{if
html}[[$n_{\bullet0}$]{latex}]{if tex}</bdo> به مجموع اندازه‌گیری‌هایی که متغیر دوم‌ آن‌ها false است اشاره می کند.

{{index correlation, "phi coefficient"}}

بنابراین برای جدول پیتزا، بالای کسر یا صورت کسر می شود <bdo> 1×76−4×9 = 40</bdo>  و مخرج کسر برابر است با ریشه‌ی دوم <bdo>5×85×10×80</bdo> یا <bdo>[√340000]{if
html}[[$\sqrt{340000}$]{latex}]{if tex}</bdo>٫   که حاصل می شود <bdo>_ϕ_ ≈
0.069</bdo>  که عدد خیلی کوچکی است. خوردن پیتزا به نظر می رسد تاثیری در تبدیل ژاک به سنجاب ندارد.

## محاسبه‌ی ضریب همبستگی

{{index [array, "as table"], [nesting, "of arrays"]}}

در جاوااسکریپت می توانیم یک جدول دو-در-دو را با یک آرایه‌ی چهار-عنصری <bdo>`[76, 9, 4, 1]`</bdo> نشان دهیم.  همچنین می توان به شکل‌ها دیگر نیز این کار را کرد مثل استفاده از آرایه‌ای که از دو آرایه‌ی دو خانه‌ای تشکیل شده است <bdo>(`[[76, 9], [4, 1]]`)</bdo>  یا شیءای با خاصیت هایی به شکل `"11"` و `"01"`، اما استفاده از یک آرایه‌ی تخت ساده تر است و باعث می شود که عبارت‌هایی که برای دسترسی به خانه‌های آرایه می نویسیم کوتاه تر شوند. خانه‌های آرایه را به عنوان دو بیت دودویی محسوب می کنیم که رقم چپ (با ارزش‌ترین عدد) نمایانگر متغیر سنجاب‌شدن و رقم راست (کم ارزش ترین) معرف متغیر رخداد است. به عنوان مثال عدد دودویی `10` به موردی اشاره می کند که ژاک به سنجاب تبدیل شده است اما رخداد مورد نظر (مثلا خوردن پیتزا) رخ نداده است . این کار چهار مرتبه اتفاق افتاده است و به علت اینکه عدد دودویی  `10` در سیستم دهدهی معادل `2` می باشد، ما این عدد را در خانه‌ی 2 آرایه ذخیره خواهیم کرد.

{{index "phi coefficient", "phi function"}}

{{id phi_function}}

تابع زیر محاسبه‌ی مقدار _ϕ_ را از آرایه‌ی مذکور انجام می دهد:


```{includeCode: strip_log, test: clip}
function phi(table) {
  return (table[3] * table[0] - table[2] * table[1]) /
    Math.sqrt((table[2] + table[3]) *
              (table[0] + table[1]) *
              (table[1] + table[3]) *
              (table[0] + table[2]));
}

console.log(phi([76, 9, 4, 1]));
// → 0.068599434
```

{{index "square root", "Math.sqrt function"}}

کد بالا در واقع ترجمه‌ی مستقیم فرمول محاسبه _ϕ_ به زبان جاوااسکریپت است. تابع <bdo>`Math.sqrt`</bdo> ریشه‌ی دوم عدد را حساب می کند که توسط شیء `Math` در محیط استاندارد جاوااسکریپت فراهم شده است. برای دستیابی به فیلد‌هایی شبیه به <bdo>[n~1•~]{if
html}[[$n_{1\bullet}$]{latex}]{if tex}</bdo> بایستی دو فیلد از جدول را با هم جمع کنیم چرا که مجموع ردیف ها یا ستون‌ها به شکل مستقیم در ساختار داده‌ی ما ذخیره نمی شوند.

{{index "JOURNAL data set"}}

ژاک به ثبت روزانه‌ی خود برای سه ماه ادامه داد. مجموعه داده‌های بدست آماده را می توانید در قسمت [کدهای](https://eloquentjavascript.net/code#4) این فصل [
([_https://eloquentjavascript.net/code#4_](https://eloquentjavascript.net/code#4))]{if
book} بدست بیاورید. این داده‌ها در متغیر `JOURNAL` ذخیره شده اند که [فایل](https://eloquentjavascript.net/code/journal.js) آن قابل دانلود است.

{{index "tableFor function"}}

برای استخراج یک ((جدول)) دو-در-دو برای یک رخداد خاص از دفتر روزانه، بایستی تمامی رکوردها را پیمایش کنیم و تعداد دفعاتی که آن رخداد در ارتباط با سنجاب شدن اتفاق افتاده است را بشماریم.

```{includeCode: strip_log}
function tableFor(event, journal) {
  let table = [0, 0, 0, 0];
  for (let i = 0; i < journal.length; i++) {
    let entry = journal[i], index = 0;
    if (entry.events.includes(event)) index += 1;
    if (entry.squirrel) index += 2;
    table[index] += 1;
  }
  return table;
}

console.log(tableFor("pizza", JOURNAL));
// → [76, 9, 4, 1]
```

{{index [array, searching], "includes method"}}

آرایه‌ها متدی به نام `includes` دارند که وجود یک مقدار داده شده را در آرایه بررسی می کند. تابع بالا از این متد برای بررسی وجود نام رخداد مورد نظر در لیست رخدادها برای یک روز مشخص استفاده می کند.

{{index [array, indexing]}}



بدنه‌ی حلقه‌ی تابع `tableFor` مشخص می کند هر کدام از مدخل‌های دفتر روزانه در کدام قسمت از جدول قرار می گیرند .اینکار با بررسی بودن رخداد مورد نظر در مدخل و اینکه رخداد همزمان با سنجاب شدن اتفاق می افتد یا خیر، صورت می گیرد. سپس حلقه یک واحد به قسمت درست در جدول اضافه می کند.

هم اکنون ما ابزاری که برای محاسبه همبستگی ها نیاز داشتیم را در اختیار داریم. تنها گامی که مانده است پیدا کردن ضریب همبستگی برای همه‌ی رخدادهای ضبط شده است و اینکه ببینیم کدام رخداد موثر است.

{{id for_of_loop}}

## حلقه‌ها در آرایه

{{index "for loop", loop, [array, iteration]}}

در تابع `tableFor` حلقه‌ای وجود داشت که شبیه کد زیر بود:

```
for (let i = 0; i < JOURNAL.length; i++) {
  let entry = JOURNAL[i];
  // Do something with entry
}
```

این شکل از حلقه در جاوااسکریپت کلاسیک رایج است – که در آن هر بار سراغ یک خانه‌ از آرایه می رویم که برای انجام آن شمارنده‌ای متناسب با طول آرایه استفاده می کنیم تا بتوانیم به هر عنصر دسترسی داشته باشیم.

راه ساده‌تری در جاوااسکریپت مدرن برای این گونه حلقه ها وجود دارد.

```
for (let entry of JOURNAL) {
  console.log(`${entry.events.length} events.`);
}
```

{{index "for/of loop"}}

زمانی که یک حلقه‌ی `for` به این شکل نوشته می شود که بعد از تعریف یک متغیر، کلمه‌ی کلیدی `of` نوشته می شود، مقداری که بعد از `of` می آید را پیمایش می کند. این حلقه نه تنها برای آرایه‌ها کاربرد دارد بلکه برای رشته‌ها و بعضی از دیگر ساختارهای داده نیز استفاده می شود. با نحوه‌ی عملکر آن در [فصل
?](object) آشنا می شویم.

{{id analysis}}

## تحلیل نهایی

{{index journal, "weresquirrel example", "journalEvents function"}}

لازم است تا محاسبه‌ی ضریب همبستگی را برای همه‌ی رخدادهایی که در مجموعه‌‌ی داده ها وجود دارد انجام دهیم. برای این کار، ابتدا باید همه‌ی انواع رخداد ها را _پیدا_ کنیم.

{{index "includes method", "push method"}}

```{includeCode: "strip_log"}
function journalEvents(journal) {
  let events = [];
  for (let entry of journal) {
    for (let event of entry.events) {
      if (!events.includes(event)) {
        events.push(event);
      }
    }
  }
  return events;
}

console.log(journalEvents(JOURNAL));
// → ["carrot", "exercise", "weekend", "bread", …]
```
با پیمایش تک تک رخدادها و افزودن آن‌هایی که قبلا در آرایه‌ی `events` موجود نبودند، این تابع تمامی رخدادها را جمع‌آوری می کند.

با استفاده از آن می توانیم همه‌ی ((همبستگی)) ها را ببینیم.

```{test: no}
for (let event of journalEvents(JOURNAL)) {
  console.log(event + ":", phi(tableFor(event, JOURNAL)));
}
// → carrot:   0.0140970969
// → exercise: 0.0685994341
// → weekend:  0.1371988681
// → bread:   -0.0757554019
// → pudding: -0.0648203724
// and so on...
```

بیشتر ضرایب همبستگی به نظر می رسد که به صفر نزدیک هستند. خوردن هویج، نان، یا دسر، ظاهرا ارتباطی با سنجاب شدن ژاک ندارند. به نظر می رسد این تبدیل بیشتر در آخر هفته‌ها رخ می دهد. اجازه بدهید تا نتایج را کمی پالایش کنیم تا فقط نتایجی نشان داده شوند که ضریب همبستگی آن ها بیش از <bdo>0.1</bdo> یا کمتر از <bdo>-0.1</bdo>  باشد.

```{test: no, startCode: true}
for (let event of journalEvents(JOURNAL)) {
  let correlation = phi(tableFor(event, JOURNAL));
  if (correlation > 0.1 || correlation < -0.1) {
    console.log(event + ":", correlation);
  }
}
// → weekend:        0.1371988681
// → brushed teeth: -0.3805211953
// → candy:          0.1296407447
// → work:          -0.1371988681
// → spaghetti:      0.2425356250
// → reading:        0.1106828054
// → peanuts:        0.5902679812
```

آها! دو فاکتور در بین نتایج وجود دارد که ضریب آن ها مشخصا قوی تر از دیگر موارد است. خوردن بادم زمینی اثر مثبت زیادی در شانس تبدیل شدن به سنجاب دارد، در حالیکه مسواک زدن اثری قابل توجه اما در جهت معکوس ایجاد می کند.

جالب است. اجازه بدهید تا چیزی را آزمایش کنیم.

```
for (let entry of JOURNAL) {
  if (entry.events.includes("peanuts") &&
     !entry.events.includes("brushed teeth")) {
    entry.events.push("peanut teeth");
  }
}
console.log(phi(tableFor("peanut teeth", JOURNAL)));
// → 1
```

نتیجه‌ی قابل توجه‌ای است. تبدیل دقیقا زمانی رخ می دهد که ژاک بادم زمینی می خورد و فراموش می کند تا مسواک کند. اگر او آن قدر بی توجه به بهداشت دهان و دندان نبود ، هرگز به این رنج دچار نمی شد.

با دانستن این، ژاک دیگر بادام زمینی نمی خورد و متوجه می شود که تبدیل دیگر اتفاق نمی افتد.

{{index "weresquirrel example"}}

تا چند سال، اوضاع برای ژاک خیلی خوب پیش می رود. تا این که روزی کارش را از دست می دهد. چون ژاک در کشوری زندگی می کند که نداشتن کار به معنای نداشتن خدمات بهداشت و سلامت است، مجبور می شود تا در یک سیرک مشغول به کار شود جایی که نقشش _مرد سنجابی شگفت‌انگیز_ است. او قبل از هر نمایش دهانش را پر از کره‌ بادم زمینی می کند.

یک روز، ژاک خسته از این زندگی رقت انگیز، وقتی نتوانست به شکل انسانی خودش برگردد، لابلای یکی از شکاف‌های چادر سیرک می پرد و در جنگل ناپدید می شود. بعد از آن ژاک هرگز دیده نشد.

## کمی آرایه‌شناسی بیشتر

{{index [array, methods], [method, array]}}

قبل از تمام کردن این فصل، قصد دارم تا شما را با چند مفهوم دیگر مرتبط با اشیاء آشنا کنم. ابتدا با چند متد عمومی و مفید از آرایه ها آشنا می شویم.

{{index "push method", "pop method", "shift method", "unshift method"}}

`pop` و `push` را [پیش‌تر](data#array_methods) در همین فصل دیدیم، که برای حذف و اضافه عناصر در انتهای آرایه استفاده می شدند. متدهای مرتبط دیگری که همین کار را در ابتدای آرایه انجام می دهند `shift` و `unshift` می باشند.

```
let todoList = [];
function remember(task) {
  todoList.push(task);
}
function getTask() {
  return todoList.shift();
}
function rememberUrgently(task) {
  todoList.unshift(task);
}
```

{{index "task management example"}}

کار برنامه‌ی بالا مدیریت صف وظایف است. برای افزودن یک وظیفه به انتهای صف، تابع <bdo>`remember("groceries")`</bdo> را فراخوانی می کنید و زمانی که برای انجام یک وظیفه آماده هستید ، تابع <bdo>`getTask()`</bdo> را برای گرفتن (و حذف) یک وظیفه از جلوی صف فراخوانی می کنید. تابع `rememberUrgently` نیز برای افزودن یک وظیفه استفاده می شود اما آن را به جلوی صف اضافه می کند نه انتهای صف.

{{index [array, searching], "indexOf method", "lastIndexOf method"}}

برای جستجوی یک مقدار خاص، آرایه‌ها متدی به نام `indexOf` را فراهم می کنند. این متد در طول آرایه از شروع تا پایان حرکت کرده و اندیسی که در آن، مقدار مورد درخواست پیدا شد – یا <bdo>-1</bdo> در صورت پیدا نکردن – را بر می گرداند. برای جستجو از آخر به اول، متدی مشابهی وجود دارد که  `lastIndexOf` نامیده می شود.

```
console.log([1, 2, 3, 2, 1].indexOf(2));
// → 1
console.log([1, 2, 3, 2, 1].lastIndexOf(2));
// → 3
```
هر دوی `indexOf` و `lastIndexOf` آرگومان اختیاری دیگری قبول می کنند که برای مشخص کردن نقطه‌ی شروع جستجو استفاده می شود.

{{index "slice method", [array, indexing]}}

یکی دیگر از متدهای اساسی آرایه‌ها، متد `slice` است که شماره‌ی اندیس های شروع و پایان را گرفته و آرایه‌ای که شامل عناصر بین آن‌ها می شود را تولید می کند. این آرایه تولیدی شامل عنصر آغازین و فاقد عنصر پایانی خواهد بود.

```
console.log([0, 1, 2, 3, 4].slice(2, 4));
// → [2, 3]
console.log([0, 1, 2, 3, 4].slice(2));
// → [2, 3, 4]
```

{{index [string, indexing]}}

زمانی که اندیس پایانی به متد داده نشود، `slice` تمامی عناصری که بعد از اندیس آغازین قرار می گیرند را بر می گرداند. می توانید همچنین اندیس اول را هم مشخص نکنید که باعث می شود کل آرایه کپی شود.

{{index concatenation, "concat method"}}

متد `concat` برای چسباندن آرایه‌ها بهم و ساخت یک آرایه جدید استفاده می شود، شبیه کاری که عملگر `+` برای رشته‌ها انجام می دهد.

مثال پیش رو نحوه‌ی عملکرد هر دوی متدهای  `slice`  و `concat` را نشان می  دهد.  تابع مثال، یک آرایه و یک اندیس را به عنوان ورودی دریافت می کند و آرایه‌ی جدیدی را برمی گرداند که نسخه‌ای از آرایه‌ی دریافتی بدون عنصری که اندیسش داده شده است می باشد.

```
function remove(array, index) {
  return array.slice(0, index)
    .concat(array.slice(index + 1));
}
console.log(remove(["a", "b", "c", "d", "e"], 2));
// → ["a", "b", "d", "e"]
```
اگر به متد `concat` آرگومانی غیرآرایه‌ای بفرستید، این مقدار به عنوان یک آرایه‌ی تک عنصری محسوب می شود و به انتهای آرایه‌ی جدید اضافه خواهد شد.

## رشته‌ها و خاصیت‌هایشان

{{index [string, properties]}}

می توانیم خاصیت‌هایی مثل `length` و `toUpperCase` را از مقدارهای رشته‌ای بخوانیم. اما اگر سعی کنید خاصیت جدید به آن‌ها اضافه کنید، نتیجه‌ای نخواهد داشت.

```
let kim = "Kim";
kim.age = 88;
console.log(kim.age);
// → undefined
```
مقادیر نوع رشته، عدد و بولی، شیء محسوب نمی شوند. درست است که اگر سعی کنید خاصیت جدیدی روی آن تعریف کنید، مفسر جاوااسکریپت خطایی تولید نمی کند، اما این خاصیت ها را هم ایجاد و ذخیره نمی کند. همانطور که پیش‌تر گفته شد، این گونه مقادیر قابل تغییر نیستند.

{{index [string, methods], "slice method", "indexOf method", [string, searching]}}

اما این انواع داده، دارای خاصیت‌هایی از پیش تعریف شده می باشند.  هر مقدار رشته‌ای حاوی چند متد است. `slice` و `indexOf` از متدهای بسیار کاربردی رشته‌ها هستند که به  متدهایی با همین نام‌ها در آرایه‌ها، شباهت دارند.

```
console.log("coconuts".slice(4, 7));
// → nut
console.log("coconut".indexOf("u"));
// → 5
```

یک تفاوت `indexOf` رشته نسبت به آرایه، توانایی جستجو رشته‌ای است که شامل بیش از یک کاراکتر می باشد در حالی که در متد مربوط به آرایه، فقط جستجو را روی عناصر تکی انجام می دهد.

```
console.log("one two three".indexOf("ee"));
// → 11
```

{{index [whitespace, trimming], "trim method"}}

متد `trim` فضای خالی را ( شامل فضای خالی، کاراکتر خط جدید، کاراکتر تب، و کاراکترهای مشابه) از آغاز و پایان رشته حذف می کند.

```
console.log("  okay \n ".trim());
// → okay
```

تابع `zeroPad` که در [فصل قبل](functions) نوشتیم نیز به عنوان یک متد وجود دارد. اسم این متد `padStart` است و طول دلخواه و کاراکتر ترازبندی را به عنوان آرگومان می گیرد.

```
console.log(String(6).padStart(3, "0"));
// → 006
```

{{id split}}

می توانید با استفاده از متد `split` یک رشته را بر اساس تکرار رشته‌ای دیگر تقسیم و جدا کنید و با استفاده از متد `join` دوباره بهم بچسبانید.

```
let sentence = "Secretarybirds specialize in stomping";
let words = sentence.split(" ");
console.log(words);
// → ["Secretarybirds", "specialize", "in", "stomping"]
console.log(words.join(". "));
// → Secretarybirds. specialize. in. stomping
```

{{index "repeat method"}}

یک رشته را می توان با استفاده از متد `repeat` تکرار کرد که در این صورت رشته‌ای جدید تولید می شود که حاوی کپی های متعدد از رشته‌ای اصلی است که به هم چسبیده اند.

```
console.log("LA".repeat(3));
// → LALALA
```

{{index ["length property", "for string"], [string, indexing]}}

پیش از این، با خاصیت `length` برای نوع رشته آشنا شدیم. دستیابی به کاراکترهای یک رشته شبیه دستیابی به عناصر یک آرایه است ( با در نظر گرفتن یک نکته که در [فصل
?](higher_order#code_units) به آن می پردازیم).

```
let string = "abc";
console.log(string.length);
// → 3
console.log(string[1]);
// → b
```

{{id rest_parameters}}

## سایر پارامتر‌ها

{{index "Math.max function"}}

امکان مفیدی است اگر یک تابع می بتواند به تعداد دلخواه آرگومان دریافت کند. به عنوان مثال، `Math.max` بیشینه‌ی _همه_ آرگومان‌هایی که به آن داده می شود را بر می گرداند.

{{index "period character", "max example", spread}}

برای نوشتن این گونه توابع، بایستی سه علامت نقطه قبل از آخرین ((پارامتر)) تابع قرار دهید، شبیه مثال زیر:


```{includeCode: strip_log}
function max(...numbers) {
  let result = -Infinity;
  for (let number of numbers) {
    if (number > result) result = number;
  }
  return result;
}
console.log(max(4, 1, 9, -2));
// → 9
```

زمانی که تابعی با این تعریف فراخوانی شود، _((پارامتر "سایر"))_ به آرایه‌ای که حاوی تمامی دیگر آرگومان‌ها می باشد اشاره می کند. اگر پارامترهای دیگری قبل از آن وجود داشته باشند، مقدار‌ آن ها در آن آرایه قرار نمی گیرد. در حالتی که، مانند متد `max`، اولین پارامتر به این صورت تعریف شود، تمامی آرگومان ها را در بر خواهد گرفت.

{{index [function, application]}}

با استفاده از این نماد سه نقطه‌ای، می توانید یک تابع را با آرایه‌ای از آرگومان‌ها _فراخوانی_ کنید.

```
let numbers = [5, 1, 7];
console.log(max(...numbers));
// → 7
```
این کار باعث می شود که آرایه‌ی مورد نظر در فراخوانی تابع ((پخش)) بشود، به طوری که عناصرش به عنوان آرگومان‌های جدا محسوب شوند.  همچنین می توان آرایه‌ی مشابهی را لابه‌لای دیگر آرگومان ها ارسال کرد مثل :‌ <bdo>`max(9, ...numbers, 2)`</bdo>.

{{index [array, "of rest arguments"], "square brackets"}}

به  طور مشابه ، براکت‌های آرایه این امکان را به شما می دهند که از عملگر سه‌نقطه برای پخش آرایه‌ای دیگر در یک آرایه‌ی جدید استفاده کنید:

```
let words = ["never", "fully"];
console.log(["will", ...words, "understand"]);
// → ["will", "never", "fully", "understand"]
```

## شیء Math

{{index "Math object", "Math.min function", "Math.max function", "Math.sqrt function", minimum, maximum, "square root"}}

همانطور که دیده‌ایم، `Math` حاوی تعدادی تابع کاربردی مرتبط با اعداد است، مثل <bdo>`Math.max`</bdo>  (بیشینه)، <bdo> `Math.min`</bdo> (کمینه)، و <bdo>`Math.sqrt`</bdo> (ریشه دوم عدد).

{{index namespace, [object, property]}}

{{id namespace_pollution}}

شیء `Math` به عنوان یک ظرف برای گروه‌بندی قابلیت‌های مرتبط استفاده می شود. تنها یک شیء `Math` وجود دارد، و تقریبا هرگز کاربردی به عنوان یک مقدار ندارد. در عوض، فضای نامی (_namespace_) را فراهم می کند که باعث می شود نیازی نباشد این متدها و مقدارها در فضای سراسری تعریف شوند.

{{index [binding, naming]}}

داشتن متغیرهای سراسری زیاد، به نوعی موجب آلودگی فضای نام (namespace)می شود. هرچه نام‌های بیشتری اشغال شوند ، احتمال بیشتری برای جایگزینی ناخواسته و تصادفی مقدار متغیرها وجود دارد. به عنوان مثال، بعید نیست که بخواهید چیزی را به نام  `max` در یکی از برنامه‌هایتان تعریف کنید. اما به دلیل اینکه تابع از پیش تعریف شده‌ی  `max` در جاوااسکریپت  به شکل امنی درون شیء `Math` نگه داری می شود، نیازی نیست نگران تغییر تصادفی آن باشیم.

{{index "let keyword", "const keyword"}}

خیلی از زبان‌های برنامه نویسی، مانع از تعریف متغیری می شوند که قبلا تعریف شده است یا حداقل به شما در این باره اخطار می دهند. جاوااسکریپت این کار را برای متغیرهایی که با `let` یا `const` تعریف شده اند انجام می دهد اما عجیب اینکه برای متغیرهایی که با `var`، توابعی که با `function` تعریف شده اند و متغیرهای استاندارد زبان، حرکتی بروز نمی دهد.

{{index "Math.cos function", "Math.sin function", "Math.tan function", "Math.acos function", "Math.asin function", "Math.atan function", "Math.PI constant", cosine, sine, tangent, "PI constant", pi}}

برگردیم به شیء `Math`. اگر نیاز به محاسبات ((مثلثاتی)) دارید ، `Math` می تواند به شما کمک کند. مانند متدهای  `cos` (کسینوس)، `sin` (سینوس)، و `tan` (تانژانت) به همراه توابع معکوس آن‌ها، `acos` `asin` و `atan`. عدد π (پی) – در واقع نزدیک ترین تقریبی که برای آن در جاوااسکریپت وجود دارد – نیز به صورت <bdo>`Math.PI`</bdo> در دسترس است. یک سنت قدیمی در برنامه نویسی وجود دارد که نام ((ثابت)) ها را با حروف بزرگ می نویسند.

```{test: no}
function randomPointOnCircle(radius) {
  let angle = Math.random() * 2 * Math.PI;
  return {x: radius * Math.cos(angle),
          y: radius * Math.sin(angle)};
}
console.log(randomPointOnCircle(2));
// → {x: 0.3667, y: 1.966}
```

اگر با سینوس و کسینوس آشنا نیستنید، نگران نباشید. زمانی که به سراغ استفاده از آن ها خواهیم رفت،‌در [در فصل ?](dom#sin_cos)، آن ها را توضیح خواهم داد.

{{index "Math.random function", "random number"}}

در مثال قبل از`Math.random` استفاده شد. این تابع عددی تصادفی بین صفر (به غیر از خود صفر) و یک (شامل خود یک) با هر بار فراخوانی، تولید می کند.

```{test: no}
console.log(Math.random());
// → 0.36993729369714856
console.log(Math.random());
// → 0.727367032552138
console.log(Math.random());
// → 0.40180766698904335
```

{{index "pseudorandom number", "random number"}}

اگرچه کامپیوتر ها ماشین‌هایی قطعی محسوب می شوند- همیشه به ورودی یکسان، واکنش یکسانی بروز می دهند –  می توان از آن ها خواست تا اعدادی که ظاهرا تصادفی هستند را تولید کنند. برای این کار، کامپیوتر بعضی مقادیر مخفی را در نظر می گیرد، و هر وقت که شما درخواست عدد تصادفی می کنید، محاسبات پیچیده‌ای را روی آن مقدارهای مخفی انجام می دهد تا مقدار جدیدی بسازد.  مقدار جدید را ذخیره کرده و عددی که از آن گرفته شده را به عنوان پاسخ برمی گرداند. با این روش، قادر است که اعداد جدیدی تولید کند که به سختی قابل پیش بینی اند طوری که _به نظر_ تصادفی می آیند.

{{index rounding, "Math.floor function"}}

اگر به جای اعداد اعشاری، به عدد تصادفی کامل(صحیح) نیاز داریم،‌می توانیم از متد <bdo>`Math.floor`</bdo> (که عدد ورودی‌اش را به نزدیک ترین عدد کوچکتر کامل گرد می کند ) برای نتیجه <bdo>`Math.random`</bdo> استفاده کنیم.

```{test: no}
console.log(Math.floor(Math.random() * 10));
// → 2
```
ضرب عدد تصادفی در عدد 10 باعث می شود که عددی بزرگتر مساوی 0 و کوچکتر از 10 را تولید کنیم. به علت اینکه <bdo>`Math.floor`</bdo> به سمت پایین عدد را گرد می کند،  این عبارت، عددی تصادفی بین 0 تا 9 را تولید می کند.

{{index "Math.ceil function", "Math.round function", "Math.abs function", "absolute value"}}

همچنین توابع دیگری وجود دارد مثل <bdo>`Math.ceil`</bdo>  برای گرد کردن به سمت بالا (سقف)، <bdo>`Math.round`</bdo> تولید نزدیک ترین عدد صحیح و <bdo>`Math.abs`</bdo> برای بدست آوردن قدرمطلق عدد (اندازه مطلق عدد فارغ از علامت آن، اعداد منفی را منفی کرده و به اعداد مثبت کاری ندارد).

## تجزیه کردن (destructring)

{{index "phi function"}}

اجازه بدهید به تابع محاسبه `phi` (فی) برگردیم:

```{test: wrap}
function phi(table) {
  return (table[3] * table[0] - table[2] * table[1]) /
    Math.sqrt((table[2] + table[3]) *
              (table[0] + table[1]) *
              (table[1] + table[3]) *
              (table[0] + table[2]));
}
```

{{index "destructuring binding", parameter}}

یکی از دلایلی که این تابع خوانایی سختی دارد این است که متغیری داریم که به آرایه‌ی ما ارجاع می دهد، در حالیکه بهتر این بود که متغیرهایی برای اشاره به _عناصر_ آرایه داشتیم، مثل، <bdo>`let n00 = table[0]`</bdo> و از این قبیل. خوشبختانه راه مختصری برای این کار در جاوااسکریپت تعبیه شده است.

```
function phi([n00, n01, n10, n11]) {
  return (n11 * n00 - n10 * n01) /
    Math.sqrt((n10 + n11) * (n00 + n01) *
              (n01 + n11) * (n00 + n10));
}
```

{{index "let keyword", "var keyword", "const keyword", [binding, destructuring]}}

این روش برای متغیرهایی که با `let`، `var` یا `const` تعریف شده اند نیز کار می کند. اگر می دانید که مقدار مورد نظر، یک آرایه است، می توانید از براکت‌ها برای دسترسی به درون آن مقدار استفاده کرده و محتوایش را مورد ارجاع قرار دهید.

{{index [object, property], [braces, object]}}

روش مشابهی برای اشیاء نیز وجود دارد، استفاده از کروشه به جای براکت‌.

```
let {name} = {name: "Faraji", age: 23};
console.log(name);
// → Faraji
```

{{index null, undefined}}

توجه داشته باشید، اگر سعی کنید `null` یا `undefined` را تجزیه کنید، با خطا مواجه خواهید شد، درست شبیه اینکه بخواهید مستقیما به خاصیتی از این دو مقدار اشاره کنید.

## JSON

{{index [array, representation], [object, representation], "data format", [memory, organization]}}

به دلیل این واقعیت که خاصیت‌ها (properties)، به مقدارهای متناظرشان فقط دسترسی دارند نه اینکه واقعا آن‌ها را نگه‌داری کنند، آرایه‌ها و اشیاء به صورت دنباله‌ای از بیت‌ها در حافظه‌ی کامپیوتر ذخیره می شوند که آدرس‌های محتوای مرتبطشان را نگه داری می کنند (مکان‌های حافظه). بنابراین یک آرایه که آرایه‌ای دیگر درون آن قرار گرفته حداقل از یک ناحیه‌ی حافظه برای آرایه‌ی درونی، و ناحیه‌ای دیگر برای آرایه‌ی بیرونی تشکیل شده است، که حاوی (علاوه بر چیزهای دیگر) یک عدد دودویی است که نمایانگر موقعیت آرایه درونی می باشد.

اگر بخواهید که داده‌ها را برای استفاده در آینده، در یک فایل ذخیره کنید ، یا به کامپیوتر دیگری در شبکه ارسال کنید، می بایست به نحوی این آدرس‌های حافظه را تبدیل به توصیفاتی کنید که بتوان آن را ذخیره یا ارسال کرد.  می توانستید تمام حافظه‌ی کامپیوتر را همراه با آدرس مقدار مورد نظر ارسال کنید، ظاهرا شدنی است، اما به نظر می رسد روش خیلی خوبی محسوب نمی شود.

{{indexsee "JavaScript Object Notation", JSON}}

{{index serialization, "World Wide Web"}}

کاری که می توانیم در این موقعیت بکنیم این است که داده ها را پشت سرهم ردیف کنیم( سریالایز). به این معنا که آن را تبدیل به متنی تخت در بیاوریم. یکی از فرمت‌های محبوب سریال کردن داده ها _((JSON))_ نامیده می شود ( که جی سن تلفظ می شود)، که مخفف نشانه‌گذاری شیء جاوااسکریپت است (javascript object notation). این روش به طور گسترده به عنوان روشی برای ذخیره داده‌ها و ارسال/دریافت آن ها در وب استفاده می شود، حتی در دیگر زبان‌های برنامه نویسی غیر ازجاوااسکریپت نیز معمول است.

{{index [array, notation], [object, creation], [quoting, "in JSON"], comment}}

JSON با کمی محدودیت، بسیار شبیه به روش جاوااسکریپت در نوشتن آرایه‌ها و اشیاء به نظر می رسد. نام خاصیت ها بایستی حتما با نقل قول جفتی احاطه شوند، و فقط عبارت‌های داده‌ای ساده قابل قبول هستند – متغیرها، فراخوانی توابع، یا هرچیزی که شامل محاسبه‌ی عملی باشد مجاز نیستند. توضیحات هم در JSON مجاز نیستند.

یک مدخل گزارش روزانه ممکن است شبیه زیر باشد اگر به فرمت JSON  نوشته شود:

```{lang: "application/json"}
{
  "squirrel": false,
  "events": ["work", "touched tree", "pizza", "running"]
}
```

{{index "JSON.stringify function", "JSON.parse function", serialization, deserialization, parsing}}

جاوااسکریپت دو متد <bdo>`JSON.stringify`</bdo>  و <bdo>`JSON.parse`</bdo> را در اختیار ما قرار داده است تا بتوانیم داده‌ها را به JSON تبدیل یا‌ از آن استخراج کنیم. تابع اول یک مقدار جاوااسکریپتی را گرفته و به رشته‌ای با فرمت JSON تبدیل می کند. تابع دوم رشته‌ای با فرمت JSON را گرفته و آن را به مقداری که درون رشته تعبیه شده است تبدیل می کند.

```
let string = JSON.stringify({squirrel: false,
                             events: ["weekend"]});
console.log(string);
// → {"squirrel":false,"events":["weekend"]}
console.log(JSON.parse(string).events);
// → ["weekend"]
```

## خلاصه

آشیاء و آرایه ها ( آرایه‌ها هم شکلی خاصی از آشیاء هستند) روش‌هایی  فراهم می کنند که به وسیله‌ی آن‌ها، مقادیر متعددی را گروه‌بندی کرده و به عنوان یک مقدار در اختیار داشته باشیم. به لحاظ مفهومی، این کار ما را قادر می سازد به جای نگه‌داری چیزهای متعدد با دست، آن‌ها را در سبدی قرار داده و با خودمان جابجا کنیم.

اکثر مقادیر در جاواسکریپت داری مجموعه‌ای از خاصیت‌ها می باشند، مورد استثنا `null` و `undefined` است. می توان به خاصیت ها به صورت <bdo>`value.prop`</bdo> یا <bdo>`value["prop"]`</bdo> دسترسی داشت. در اشیاء، خاصیت ها نام گذاری می شوند و معمولا مجموعه‌ی ثابتی از آن ها را نگه داری می کنند. آرایه‌ها، از سویی دیگر، حاوی تعداد متنوعی از مقدارهای معمولا یک جنس می باشند و از اعداد ( با شروع از صفر) به عنوان نام خاصیت‌هایشان استفاده می کنند.

البته بعضی خاصیت‌ها در آرایه‌ها وجود دارند که نام‌گذاری شده اند؛ مانند `length` و بعضی دیگر. متدها توابعی هستند که در خاصیت‌ها قرار دارند و (معمولا) روی مقداری که خاصیتی از آن محسوب می شوند عمل می کنند.

می توانی عناصر یک آرایه را به وسیله نوع خاصی از حلقه‌ی  `for` پیمایش کنید.
<br>
<bdo>for (let element of array)</bdo>

## تمرین‌ها

### مجموع یک بازه

{{index "summing (exercise)"}}

در [مقدمه‌ی](intro) این کتاب، به مثال زیر به عنوان یک راه خوب برای محاسبه مجموع بازه‌ای از اعداد اشاره شد:

```{test: no}
console.log(sum(range(1, 10)));
```

{{index "range function", "sum function"}}

تابعی به نام `range` بنویسید که دو آرگومان را دریاف می کند، `start` و `end` و آرایه‌ای بر می گرداند که حاوی تمامی اعدادی باشد که از `start` شروع شده و با عدد `end` پایان می یابد.

سپس، تابعی به نام `sum` بنویسید که آرایه‌ای از اعداد را گرفته و مجموع این اعداد را بر می گرداند. برنامه‌ ای که در مثال آمده را اجرا کرده و بررسی کنید که آیا 55 را به عنوان پاسخ بر می گرداند؟


{{index "optional argument"}}

به عنوان یک ماموریت تشویقی، تابع `range` خود را تغییر دهید تا آرگومان اختیاری سومی هم قبول کند. این آرگومان گام (step) را برای ساختن آرایه مشخص می کند. اگر گامی مشخص نشود، عناصر آرایه، مثل حالت پیش‌فرض، با یک واحد افزایش می یابند. فراخوانی تابع به شکل <bdo>`range(1, 10, 2)`</bdo> بایستی خروجی <bdo>`[1, 3, 5, 7, 9]`</bdo> را تولید کند. مطمئن شوید که تابع با گام منفی هم کار خواهد کرد پس  <bdo>`range(5, 2, -1)`</bdo> بایستی <bdo>`[5, 4, 3, 2]`</bdo> را تولید کند.

{{if interactive

```{test: no}
// Your code here.

console.log(range(1, 10));
// → [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
console.log(range(5, 2, -1));
// → [5, 4, 3, 2]
console.log(sum(range(1, 10)));
// → 55
```

if}}

{{hint

{{index "summing (exercise)", [array, creation], "square brackets"}}

ساختن یک آرایه، در ساده ترین شکل با تعریف یک متغیر و انتساب `[]` (یک آرایه‌ی تازه و خالی) و فراخوانی مکرر متد `push` برای افزودن مقدار، صورت می گیرد. فراموش نکنید که در انتهای تابع، آرایه را برگردانید.

{{index [array, indexing], comparison}}

به دلیل اینکه مرز انتهایی بازه باید شامل شود، لازم است تا از عملگر  <bdo>`<=`</bdo> به جای عملگر <bdo>`<`</bdo> برای بررسی انتهای حلقه استفاده کنید.

{{index "arguments object"}}

پارامتر step را می توان به صورت یک پارامتر پیش‌فرض تعریف کرد (استفاده از عملگر `=`) و مقدار آن را 1 قرار داد.

{{index "range function", "for loop"}}

برای اینکه `range` بتواند گام منفی را پیاده سازی کنید، احتمالا بهترین روش نوشتن دو حلقه است. یکی برای شمارش به بالا و دیگری برای شمارش به پایین. چراکه عمل مقایسه‌ای که به پایان رسیدن حلقه را بررسی می کند در حالت شمارش به پایین لازم است تا از <bdo>`>=`</bdo> به جای <bdo>`<=`</bdo> استفاده کند.

خوب است در مواقعی که پایان بازه از ابتدای آن کوچکتر است، از گام پیش‌فرض دیگری استفاده شود، مثلا <bdo>-1</bdo>. با این کار، <bdo>`range(5, 2)`</bdo> خروجی معقولی خواهد داشت و در حلقه‌ی بینهایت گیر نخواد افتاد. می توان در مقدار پیش‌فرض یک پارامتر به پارامترهای قبل ارجاع داد.

hint}}

### معکوس کردن یک آرایه

{{index "reversing (exercise)", "reverse method", [array, methods]}}

آرایه‌ها متدی به نام `reverse` دارند که ترتیب عناصر آرایه را معکوس می نماید. برای این تمرین، دو تابع بنویسید:`reverseArray` و `reverseArrayInPlace`. تابع اول ، `reverseArray` آرایه ای را به عنوان ورودی می گیرد و آرایه‌ی _جدیدی_ را تولید می کند که همان عناصر را دارد اما با ترتیب وارونه. تابع دوم، `reverseArrayInPlace` مشابه‌ متد `reverse` عمل می کند: همان آرایه‌ای را که به عنوان آرگومان دریافت می کند  _تغییر می دهد_ و ترتیب عناصرش را عکس می کند. در این تمرین نمی توانید از متد استاندارد `reverse` استفاده کنید.

{{index efficiency, "pure function", "side effect"}}

به بحث اثرات جانبی و توابع ناب فکر کنید که در [فصل قبل](functions#pure) صحبت شد، به نظر شما کدام تابع از موارد بالا در موقعیت های بیشتری کاربرد خواهد داشد؟ کدام سریع‌تر عمل می کند؟

{{if interactive

```{test: no}
// Your code here.

console.log(reverseArray(["A", "B", "C"]));
// → ["C", "B", "A"];
let arrayValue = [1, 2, 3, 4, 5];
reverseArrayInPlace(arrayValue);
console.log(arrayValue);
// → [5, 4, 3, 2, 1]
```

if}}

{{hint

{{index "reversing (exercise)"}}

دو روش روشن برای پیاده‌سازی تابع `reverseArray` وجود دارد. اولین روش این است که خیلی ساده به سراغ آرایه‌ی ورودی رفته و از ابتدا تا پایان آن، از متد `unshift` برای قرار دادن تک تک عناصر درون آرایه‌ی جدید استفاده کنید.
روش دوم این است که آرایه‌ی ورودی را به صورت وارونه پیمایش کنید و از متد ‍`push` استفاده نمایید. پیمایش معکوس یک آرایه نیاز به یک حلقه‌ی `for` خاص (کمی غیرمتعارف) دارد. چیزی شبیه <bdo>`(let i = array.length - 1; i >= 0; i--)`</bdo>.

{{index "slice method"}}

وارونه کردن آرایه به صورت درجا، مشکل تر است. باید مراقب باشین عناصری که که در ادامه لازم دارید را رونویسی نکنید. استفاده از `reverseArray` یا کپی کردن کل آرایه (<bdo>`array.slice(0)`</bdo> روش خوبی برای کپی کردن یک آرایه است) کمک می کند اما تقلب محسوب می شود.

ترفند این است که عنصر‌های اول و پایانی را با هم عوض کنید، سپس عنصر دوم را با عنصر یکی مانده به پایانی و الی آخر. می توانید این کار را پیمایش نیمی از طول آرایه انجام دهید (از <bdo>`Math.floor`</bdo> برای گرد کردن استفاده کنید. نیازی نیست در آرایه‌ای با طول فرد، عنصر وسط آرایه را پیمایش کنید) و عنصر موقعیت `i` را با عنصر موقعیت <bdo>` array.length - 1 - i `</bdo> عوض کنید. می توانید از یک متغیر محلی استفاده کنید تا یک عنصر را نگه‌داری کنید، آن را با قرینه‌اش رونویسی کنید و سپس مقدار متغیر محلی را جایی قرار دهید که قرینه قبلا قرار داشت.

hint}}

{{id list}}

### لیست

{{index ["data structure", list], "list (exercise)", "linked list", array, collection}}

اشیاء به عنوان مقادیری بدون چارچوب خاص، می توانند برای ساختن هر نوع ساختار داده استفاده شوند. یکی از انواع رایج ساختار داده، _لیست_ است ( نباید لیست را با آرایه اشتباه گرفت). یک لیست مجموعه‌ای تودرتو از اشیاء است که در آن اولین شیء ارجاعی به دومین، دومین به سومین و الی آخر، نگه داری می کند.



```{includeCode: true}
let list = {
  value: 1,
  rest: {
    value: 2,
    rest: {
      value: 3,
      rest: null
    }
  }
};
```

اشیائی که در یک زنجیره وجود دارند به این شکل خواهند بود:

{{figure {url: "img/linked-list.svg", alt: "A linked list",width: "8cm"}}}

{{index "structure sharing", [memory, structure sharing]}}

یکی از نکات خوب لیست ها این است که آن ها بخشی از ساختارشان را به اشتراک می گذارند. به عنوان مثال، اگر من دو مقدار جدید ایجاد کنم <bdo>`{value: 0, rest:
list}`</bdo> و <bdo>`{value: -1, rest: list}`</bdo> (که list در اینجا به متغیری است که پیش‌تر تعریف شده است)، هر دوی آن ها لیست‌های مستقلی هستند، اما ساختاری را به اشتراک می گذارند که سه عنصر آخرشان را می سازد. لیست اصلی همچنین هنوز یک لیست سه عنصره‌ی معتبر است.

تابعی به نام `arrayToList` بنویسید که یک ساختار لیست شبیه لیستی که نشان داده شد بسازد و مقدار <bdo>`[1, 2, 3]`</bdo> را به عنوان آرگومان دریافت کند. همچنین تابعی به نام `listToArray` بنویسید که آرایه‌ای از لیست داده شده تولید کند. بعد تابع‌ کمکی `prepend` را تعریف کنید که یک عنصر به همراه یک لیست را گرفته و لیست جدیدی تولید می کند که عنصر مورد نظر در ابتدای آن اضافه شده است و تابع `nth` که یک لیست و یک عدد را گرفته و عنصری که در موقعیت خواسته شده قرار دارد را از لیست بر می گرداند ( صفر به عنصر اول اشاره می کند) یا اینکه در صورت نبودن عنصر مقدار `undefined` برگردانده می شود.

{{index recursion}}

اگر به روش بازگشتی این مسئله را حل نکرده‌اید، اکنون نسخه‌ی بازگشتی تابع `nth` را هم بنویسید.

{{if interactive

```{test: no}
// Your code here.

console.log(arrayToList([10, 20]));
// → {value: 10, rest: {value: 20, rest: null}}
console.log(listToArray(arrayToList([10, 20, 30])));
// → [10, 20, 30]
console.log(prepend(10, prepend(20, null)));
// → {value: 10, rest: {value: 20, rest: null}}
console.log(nth(arrayToList([10, 20, 30]), 1));
// → 20
```

if}}

{{hint

{{index "list (exercise)", "linked list"}}

ساختن یک لیست از انتها به ابتدا، ساده تر خواهد بود. بنابراین `arrayToList` می تواند آرایه را به صورت معکوس پیمایش کند (مانند تمرین قبل) و برای هر عنصر، یک شیء به لیست اضافه کند. می توانید از یک متغیر محلی برای نگه‌داری بخشی از لیست که تاکنون ساخته شده استفاده کنید و از انتسابی مثل <bdo> `list = {value: X, rest: list}`</bdo> برای افزودن یک عنصر بهره ببرید.

{{index "for loop"}}

برای پیمایش یک لیست ( در `listToArray` و `nth` )، یک حلقه‌ی `for` با مشخصاتی شبیه زیر، می تواند استفاده شود:

```
for (let node = list; node; node = node.rest) {}
```

می توانید کارکرد آن را توضیح دهید؟ در هر تکرار حلقه، `node` به زیرلیست فعلی اشاره می کند و بدنه می تواند خاصیت `value` آن را بخواند تا عنصر فعلی را به دست بیاورد. در انتهای یک تکرار، `node` به سراغ زیرلیست بعد می رود. زمانی که برابر null شد، ما به انتهای لیست رسیده ایم و حلقه پایان می یابد.

{{index recursion}}

نسخه‌ی بازگشتی `nth`، به طور مشابه، در هر فراخوانی بازگشتی، بخش کوچک‌تری از دنباله‌ی لیست می پردازد و همزمان عدد اندیس را کاهش می دهد تا زمانی که به صفر برسد، در نقطه‌ای که می تواند خاصیت `value` مربوط به node مورد جستجو را برگرداند. برای گرفتن عنصر صفرم یک لیست، به سادگی می توانید خاصیت `value` سرگره (head node) را بگیرید. برای گرفتن عنصر <bdo>_N_ + 1</bdo>، عنصر Nام لیست را که در خاصیت `rest` این لیست قرار دارد، می گیرید.

hint}}

{{id exercise_deep_compare}}

### مقایسه عمیق

{{index "deep comparison (exercise)", [comparison, deep], "deep comparison", "== operator"}}

عملگر `==` اشیاء را بر اساس همسانی مقایسه می کند  .  اما گاهی ممکن است بخواهید مقدارهای خاصیت‌های واقعی آن ها را مقایسه کنید.

تابعی به نام `deepEqual` بنویسید که دو مقدار را دریافت می یکند و زمانی مقدار true‌ را بر می گرداند که هر دوی مقدار ها مشابه باشند یا اگر شیء هستند خاصیت‌های یکسانی داشته باشند، به طوریکه مقدارهای خاصیت‌های آن ها نیز در صورت مقایسه با یک فراخوانی بازگشتی تابع `deepEqual`، برابر باشند.

{{index null, "=== operator", "typeof operator"}}

برای اینکه بدانیم آیا مقدارها باید مستقیما باهم مقایسه شوند ( از عملگر `===` برای آن استفاده کنید) یا اینکه خاصیت‌هایشان را باید مقایسه‌ کنیم، می توان از عملگر `typeof` استفاده کرد. اگر این عملگر `“object”` برای هر دو مقدار تولید کرد، بایستی عمل مقایسه‌ی عمیق انجام شود. راستی باید یک استثناء احمقانه را هم نیز در نظر بگیرید:  به دلیل اتفاقی قدیمی، <bdo>`typeof null`</bdo> نیز `“object”` را تولید می کند.

{{index "Object.keys function"}}

وقتی برای مقایسه‌ی خاصیت‌های اشیاء لازم است که به خاصیت‌ها دسترسی پیدا کنید، تابع <bdo>`Object.keys`</bdo> به شما کمک خواهد کرد.

{{if interactive

```{test: no}
// Your code here.

let obj = {here: {is: "an"}, object: 2};
console.log(deepEqual(obj, obj));
// → true
console.log(deepEqual(obj, {here: 1, object: 2}));
// → false
console.log(deepEqual(obj, {here: {is: "an"}, object: 2}));
// → true
```

if}}

{{hint

{{index "deep comparison (exercise)", [comparison, deep], "typeof operator", "=== operator"}}

آزمایش تشخیص شیء چیزی شبیه به <bdo>`typeof x == "object" && x != null`</bdo> خواهد بود. دقت داشته باشید فقط زمانی خاصیت‌ها را مقایسه کنید که هر دو آرگومان object (شیء) باشند. در همه‌ی موارد دیگر، می توانید نتیجه‌ی `===` را برگردانید.

{{index "Object.keys function"}}

برای گرفتن خاصیت‌ها از <bdo>`Object.keys`</bdo> استفاده کنید. لازم است ببینید که هر دوی اشیاء خاصیت‌های مشابهی داشته باشند و مقادیر آن‌ها نیز یکسان باشد. یک روش این است که مطمئن شوید هر دو، تعداد خاصیت‌های یکسانی دارند (طول لیست خاصیت‌ها مشابه باشد). و سپس، هنگام پیمایش خاصیت‌های یک شیء برای مقایسه، همیشه اول اطمینان حاصل کنید که شیء دیگر خاصیتی با همان نام داشته باشد. اگر هر دو شیء تعداد خاصیت‌ یکسانی داشته باشند و همه‌ی خاصیت‌های موجود در یکی، در دیگر نیز باشد، هر دو، مجموعه‌ی یکسانی از خاصیت‌ها را دارند.

{{index "return value"}}

بهترین روش بازگرداندن مقدار درست از یک تابع این است که هر زمان یک عدم تطبیق پیدا شد، بلافاصله false برگردانده شود و در انتهای تابع مقدار true را برگردانیم.

hint}}
