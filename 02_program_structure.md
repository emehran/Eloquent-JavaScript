# ساختار برنامه

{{quote {author: "why", title: "Why's (Poignant) Guide to Ruby", chapter: true}
سرخی قلبم از زیر پوست شفاف و نازکم می‌درخشد و آن‌ها باید به من 10 سی‌سی جاوااسکریپت تزریق کنند تا من را به زندگی برگردانند. (بدن من به وجود سم در خون خوب واکنش می‌دهد.) این آشغال فورا نفس شما را برمی‌گرداند!

quote}}

{{index why, "Poignant Guide"}}

{{figure {url: "img/chapter_picture_2.jpg", alt: "Picture of tentacles holding objects", chapter: framed}}}

در این فصل، قصد داریم کارهایی را شروع کنیم که واقعا بتوان نامشان را _برنامه‌نویسی_ گذاشت. می‌خواهیم دانش جاوااسکریپت خود را به فراتر از اسامی و بخش‌های کوچکی که تا کنون دیده‌ایم، توسعه دهیم تا به نقطه‌ای برسیم که بتوانیم برنامه‌های معناداری بسازیم.

## عبارت‌ها و دستورات

{{index grammar, [syntax, expression], [code, "structure of"], grammar, [JavaScript, syntax]}}

در [فصل ?](values)، مقادیری را ایجاد و به آن‌ها عملگرهایی اعمال کردیم تا بتوانیم مقدارهای تازه‌ای ایجاد کنیم. تولید مقدارها به این صورت، جوهر اساسی هر برنامه‌ی جاوااسکریپت است، اما این جوهر اساسی باید در یک ساختار بزرگتر قرار گیرد تا کاربردی شود. این کاری است که در این فصل به آن خواهیم پرداخت.

{{index "literal expression", [parentheses, expression]}}

قطعه کدی که باعث تولید یک مقدار می‌شود را اصطلاحا _((عبارت))_ (expression) می گویند. هر مقداری که در برنامه به طور مستقیم نوشته می‌شود (مانند `22` یا `"psychoanalysis"` ) در واقع یک عبارت است. یک عبارت اگر داخل پرانتز قرار گیرد نیز یک عبارت محسوب می‌شود. به همین ترتیب، عملگر دودویی اگر به دو عبارت اعمال شود یا عملگر یکانی اگر به یک عبارت اعمال شود، باعث تولید عبارت جدید می‌شود.

{{index [nesting, "of expressions"], "human language"}}

این شیوه کارکرد عبارت‌ها گوشه‌ای از زیبایی شباهت زبان برنامه نویسی به زبان طبیعی را نشان می دهد. درست شبیه زیر‌جمله‌ها در زبان های بشری، عبارت‌ها می توانند تو در تو باشند . یک زیرجمله می‌تواند زیرجمله‌ی دیگری را در بر داشته باشد و الی آخر. این ویژگی باعث می‌شود بتوانیم عبارت‌ها را ترکیب کنیم تا محاسبات پیچیده‌تری را انجام دهیم.

{{index statement, semicolon, program}}

اگر یک عبارت را معادل بخشی از جمله در نظر بگیریم، یک _دستور_ (statement) جاوااسکریپت را می توان یک جمله‌ی کامل در زبان بشری دانست. یک برنامه، لیستی از دستورات است.

{{index [syntax, statement]}}

ساده ترین شکل یک دستور شامل یک عبارت و یک نقطه‌ویرگول در انتهای آن است. این یک برنامه است:

```
1;
!false;
```

البته برنامه‌ی بالا، کاربردی ندارد. یک ((عبارت)) می‌تواند منجر به تولید یک مقدار شود، مقداری که بعدا توسط کدهای اطرافش استفاده شود. یک دستور به طور مستقل عمل می‌کند و زمانی می توان آن را دستوری صحیح نامید که اثری برجای بگذارد. همچنین می‌تواند چیزی را روی صفحه نمایش دهد – که اثرگذاری محسوب می‌شود – یا حالت درونی برنامه را به گونه‌ای تغییر دهد که بر عبارت هایی که بعد می آیند اثر بگذارد. این تغییرات را اثرات جانبی (_((side effect))s_) می نامند. در مثال قبل، دستوراتی که آورده شدند فقط مقدارهای `1` و `true` را تولید می کردند و بلافاصله آن ها را بدون استفاده رها می کردند. این کار به هیچ وجه اثری بر جای نمی گذارد. زمانی که این برنامه اجرا می‌شود، اتفاق قابل مشاهده‌ای رخ نمی دهد.

{{index "programming style", "automatic semicolon insertion", semicolon}}

در بعضی موارد، می توان در جاوااسکریپت از گذاشتن نقطه‌ویرگول در انتهای دستور صرف نظر کرد. در موارد دیگر، باید حتما استفاده شود، در غیر این صورت ((خط بعدی)) به عنوان ادامه‌ی دستور قبل محسوب خواهد شد. قوانین مربوط به حذف یا جایگذاری نقطه‌ویرگول در دستورات می توانند پیچیده و خطاساز باشند. بنابراین در این کتاب، هر دستوری که به نقطه‌ویرگول نیاز داشته باشد، با نقطه‌ویرگول پایان می یابد. توصیه‌ی من این است که شما نیز همین کار را بکنید، حداقل تا زمانی که اطلاعات بیشتری در مورد ریزه کاری‌های مربوط به حذف نقطه‌ویرگول بدست بیاورد.

## متغیرها

{{indexsee variable, binding}}
{{index [syntax, statement], [binding, definition], "side effect", [memory, organization], [state, in binding]}}

چگونه یک برنامه، یک وضعیت داخلی را نگه‌داری می‌کند؟ چگونه‌ برنامه مواردی را به خاطر می سپارد؟ پیش از این دیدیم که چطور می توان مقادیر جدید را از مقدارهای قبلی به وجود آورد، این کار تغییری در مقادیر قبلی به وجود نمی آورد و مقادیر جدید هم باید بلافاصله استفاده شوند وگرنه از دسترس خارج می شوند. برای حفظ این مقادیر، جاوااسکریپت راهی را پیشنهاد می دهد که _متغیر_ نامیده می‌شود:

```
let caught = 5 * 5;
```

{{index "let keyword"}}

استفاده از متغیر، نوع دومی از دستور را به ما معرفی می‌کند. _((کلمه‌ی کلیدی))_ `let` مشخص می‌کند که این جمله قرار است تا متغیری را تعریف نماید. بعد از این کلمه کلیدی، نام متغیر می‌آید و در صورتی که بخواهیم مقداری را بلافاصله به آن اختصاص دهیم، می توانیم از عملگر `=` استفاده کنیم.

دستور بالا متغیری به نام `caught` را ایجاد کرده و از آن برای نگه‌داری یک عدد که از حاصل ضرب 5 در 5 به وجود آمده است، استفاده می‌کند.

بعد از اینکه یک متغیر تعریف شد، می توان نام آن را به عنوان یک ((عبارت)) مورد استفاده قرار داد. مقدار این نوع عبارت همان مقداری است که متغیر اکنون نگه‌داری می‌کند. به مثال توجه نمایید:

```
let ten = 10;
console.log(ten * ten);
// → 100
```

{{index "= operator", assignment, [binding, assignment]}}

زمانی که یک متغیر به مقداری اشاره می‌کند، به این معنی نیست که برای همیشه به آن گره خورده است. عملگر  `=` را می توان در هر زمان استفاده کرد و متغیرهای فعلی را از مقادیری که به آن‌ها اشاره می کنند جدا کرده و به مقادیر جدیدی اختصاص داد.


```
let mood = "light";
console.log(mood);
// → light
mood = "dark";
console.log(mood);
// → dark
```

{{index [binding, "model of"], "tentacle (analogy)"}}

می توانید متغیرها را به جای جعبه به بازوچه‌ها تشبیه کنید. آن ها مقدارها را در خود _نگه_ نمی دارند، بلکه به آن‌ها _دسترسی_ دارند – دو متغیر می توانند به یک مقدار مشابه اشاره کنند. یک برنامه فقط می‌تواند به مقدارهایی که همچنان امکان رجوع به آن ها را دارد، دسترسی داشته باشد. زمانی که لازم باشد چیزی را در برنامه حفظ کنید ( به خاطر بسپارید )، بازوچه‌ای را به سمت آن می فرستید تا آن را نگه دارد یا یکی از بازوچه‌های  فعلی را مامور آن چیز می‌کنید.

اجازه دهید تا مثالی دیگر را بررسی کنیم. برای به یادآوری دلارهایی که لوئیجی هنوز به شما بدهکار است، می توانید از یک متغیر استفاده کنید. زمانی که او 35 دلار به شما پس می دهد، مقدار متغیر مورد نظر را تغییر می دهید.

```
let luigisDebt = 140;
luigisDebt = luigisDebt - 35;
console.log(luigisDebt);
// → 105
```

{{index undefined}}

زمانی که متغیری را تعریف می‌کنید اما به آن مقدار اولیه اختصاص نمی دهید، بازوچه‌ای که مثال زدیم هنوز چیزی ندارد تا به آن اشاره کند، بنابراین به جای خاصی اشاره نخواهد کرد. اگر در جایی از برنامه درخواستی برای یک متغیر خالی ارسال کنید، مقداری که به شما باز خواهد گشت مقدار `undefined` خواهد بود.

{{index "let keyword"}}

می‌توان از یک `let` برای تعریف چندین متغیر استفاده نمود. این تعریف ها باید به وسیله ویرگول جدا شوند.

```
let one = 1, two = 2;
console.log(one + two);
// → 3
```
کلمه‌های `var` و  `const` را نیز می توان به طور مشابهی برای ایجاد متغیرها استفاده کرد. درست مانند استفاده از `let`.

```
var name = "Ayda";
const greeting = "Hello ";
console.log(greeting + name);
// → Hello Ayda
```

{{index "var keyword"}}

اولین کلمه کلیدی، `var` (کوتاه شده‌ی "variable")، روشی بود که انتساب‌ها را در نسخه قبل از 2015 جاوااسکریپت با آن تعریف می کردند. در [فصل بعدی](functions) به تفاوت آن با `let` خواهیم پرداخت. فعلا، به خاطر داشته باشید که هر دوی آن‌ها در بیشتر اوقات، کار مشابهی انجام می دهند، اما در این کتاب ما به ندرت از `var` استفاده خواهیم کرد به خاطر اینکه خصوصیات گیج کننده‌ای دارد.

{{index "const keyword", naming}}

کلمه کلیدی `const` به معنای انتساب _((ثابت))_ است. این کلمه کلیدی یک ثابت تعریف می نماید که این ثابت تا زمانی که وجود دارد، به مقدار یکسانی اشاره خواهد کرد. این نوع تعریف، برای نامگذاری یک مقدار در طول برنامه برای مراجعات بعدی مفید است.

## نامگذاری انتساب‌ها (متغیرها)

{{index "underscore character", "dollar sign", [binding, naming]}}

می توان از هر کلمه‌ای برای نامگذاری انتساب‌ها استفاده کرد. می توان از ارقام برای بخشی از نام متغیر استفاده کرد – مثلا `catch22` یک نام معتبر است– اما نمی توان آن را با اعداد شروع کرد. نام یک متغیر می‌تواند شامل علامت دلار (`$`) یا زیرخط (`_`) باشد اما دیگر علامت‌های نقطه گذاری یا کاراکترهای ویژه را نمی توان استفاده نمود.


{{index [syntax, identifier], "implements (reserved word)", "interface (reserved word)", "package (reserved word)", "private (reserved word)", "protected (reserved word)", "public (reserved word)", "static (reserved word)", "void operator", "yield (reserved word)", "enum (reserved word)", "reserved word", [binding, naming]}}

کلماتی که معنای خاصی در جاوااسکریپت دارند مانند `let` را _((کلمات کلیدی))_ می نامند و نمی توان از آن ها برای نام گذاری متغیرها استفاده کرد. همچنین یک تعداد مشخصی از کلمات وجود دارند که برای نسخه‌های آینده جاوااسکریپت رزرو شده اند که نمی توان از آن‌ها نیز برای نامگذاری متغیرها استفاده کرد. لیست همه‌ی این کلمات کلیدی و رزرو شده، نسبتا لیست بلندی می‌شود.

```{lang: "text/plain"}
break case catch class const continue debugger default
delete do else enum export extends false finally for
function if implements import interface in instanceof let
new package private protected public return static super
switch this throw true try typeof var void while with yield
```

{{index [syntax, error]}}

نگران حفظ کردن کلمات بالا نباشید. اگر هنگام تعریف یک متغیر با خطایی خلاف انتظار روبرو شدید، مطمئن شوید که از کلمات لیست بالا استفاده نکرده باشید.

## محیط اجرایی

{{index "standard environment", [browser, environment]}}

به مجموعه‌ی انتساب‌ها (متغیرها) و مقادیر آن‌ها که در یک زمان مشخص فعال هستند محیط اجرایی (_((environment))_) گفته می‌شود. زمانی که برنامه‌ای اجرا می‌شود، این محیط خالی نیست و حاوی انتساب‌هایی است که بخشی از استاندارد زبان هستند. بیشتر اوقات، محیط اجرایی، مواردی را هم فراهم می نماید تا بتوان به وسیله‌ی آن‌ها با سیستم پیرامون تعامل برقرار کرد. به عنوان مثال، در یک مرورگر وب، توابعی در دسترس هستند که می توان از طریق آن ها با وب سایتی که بارگیری شده است تعامل داشت و یا  ورودی‌های ((موس)) و ((صفحه‌کلید)) را خواند.

## توابع

{{indexsee "application (of functions)", [function, application]}}
{{indexsee "invoking (of functions)", [function, application]}}
{{indexsee "calling (of functions)", [function, application]}}
{{index output, function, [function, application], [browser, environment]}}

خیلی از مقدارهایی که در محیط اجرایی پیش‌فرض، وجود دارند از نوع _((function))_ هستند. یک تابع در واقع یک قطعه یا بخشی از برنامه‌ است که در قالب یک مقدار قرار گرفته است. این نوع مقدار‌ها را می توان بکار گرفت تا برنامه‌ی موجود در آن را اجرا نمود. به عنوان مثال، در محیط مرورگر، انتساب `prompt` تابعی را نگه‌داری می‌کند که در صورت اجرا، یک پنجره‌ی گفتگویی را نشان می دهد که می‌تواند اطلاعاتی را از کاربر دریافت نماید که به شکل زیر استفاده می‌شود:

```
prompt("Enter passcode");
```

{{figure {url: "img/prompt.png", alt: "A prompt dialog", width: "8cm"}}}

{{index parameter, [function, application], [parentheses, arguments]}}

به اجرای یک تابع، _فراخوانی_، _صدازدن_، یا _بکارگیری_ آن گفته می‌شود. برای صدازدن یک تابع می توان یک جفت پرانتز را در جلوی عبارتی که یک مقدار از نوع تابع را تولید می‌کند قرار دارد. شما معمولا به طور مستقیم با متغیری که حاوی تابع است کار می‌کنید. اگر بین پرانتز مقادیری قرار گیرد، این مقادیر به برنامه‌ای که در داخل تابع قرار دارد فرستاده می‌شود. در مثال، تابع `prompt` از رشته ای که به آن می دهیم استفاده کرده و آن را به عنوان متن پنجره‌ی گفتگو نشان می‌دهد. مقدارهایی که به توابع فرستاده می شوند را _((آرگومان))_ می گوییم. توابع مختلف ممکن است به تعداد و انواع مختلف آرگومان نیاز داشته باشند.

تابع `prompt` زیاد در برنامه‌نویسی وب مدرن استفاده نمی‌شود، و علت آن بیشتر به خاطر نداشتن کنترل روی ظاهر پنجره‌ی گفتگو است. اما می توان از آن در بعضی موارد مثل برنامه‌های تفننی یا آزمایش کردن‌ها استفاده کرد.

## تابع console.log

{{index "JavaScript console", "developer tools", "Node.js", "console.log", output, [browser, environment]}}

در مثال های قبلی، من از `console.log` برای نمایش مقدارها استفاده کردم. اکثر سیستم‌های جاوااسکریپت ( شامل همه مرورگرهای مدرن و node.js) تابعی به نام `console.log` را فراهم می کنند که آرگومان‌های ورودیش را در جایی به صورت متنی نشان می دهند. در مرورگرها، این خروجی در کنسول جاوااسکریپت  قرار می گیرد. کنسول بخشی از مرورگر است که به صورت پیش فرض مخفی است،‌ اما در بیشتر مرورگرها با فشار دادن کلید F12 یا در مک با [command]{keyname}-[option]{keyname}-I در دسترس خواهد بود. اگر این کلیدهای میانبر کار نکرد، از طریق منوی مرورگر به دنبال  “developer tools” و شبیه آن بگردید.

{{if interactive

زمانی که مثال‌های اینجا(یا کدهای خودتان) را در صفحات این کتاب اجرا می‌کنید، خروجی تابع `console.log`، به جای نمایش در کنسول جاوااسکریپت مرورگر، بعد از خود مثال نشان داده خواهد شد.

```
let x = 30;
console.log("the value of x is", x);
// → the value of x is 30
```

if}}

{{index [object, property], [property, access]}}

اگرچه در نام متغیرها نمی توان از کاراکتر نقطه استفاده کرد، اما `console.log` نقطه دارد. علت آن این است که  `console.log` یک انتساب (متغیر) ساده نیست. در واقع عبارتی است که خصیصه‌ی `log` را از مقداری که در متغیر `console` نگه داری شده است بر می گرداند. در [فصل ?](data#properties)، با مفهوم آن به طور دقیق آشنا خواهیم شد.

{{id return_values}}
## بازگرداندن مقادیر

{{index [comparison, "of numbers"], "return value", "Math.max function", maximum}}

نمایش یک پنجره تعاملی یا نوشتن متن در صفحه‌ی نمایش یک _((اثر جانبی))_ تلقی می‌شود. خیلی از توابع به خاطر اثر جانبی ای که تولید می کنند کاربرد دارند. توابع همچنین می توانند مقدار تولید کنند و در این صورت نیازی به اثر جانبی ندارند تا در برنامه کاربرد داشته باشند. به عنوان مثال، تابع `Math.max` به تعداد دلخواه آرگومان عددی می گیرد و بزرگترین آن ها را برمی گرداند.

```
console.log(Math.max(2, 4));
// → 4
```

{{index [function, application], minimum, "Math.min function"}}

زمانی که یک تابع مقداری را تولید می‌کند، گفته می‌شود که آن مقدار را _برگردانده_ است. در جاوااسکریپت هرچیزی که مقداری را تولید می‌کند یک عبارت است که به این معنا است که می توان فراخوانی توابع را در عبارت‌های بزرگ‌تر صورت داد. در اینجا فراخوانی `Math.min` که عکس تابع `Math.max` می باشد، به عنوان بخشی از یک عبارت جمع حسابی استفاده شده است:

```
console.log(Math.min(2, 4) + 100);
// → 102
```
[در فصل بعد](functions) توضیح می دهیم که چگونه توابع خود را بنویسید.

## جریان کنترل

{{index "execution order", program, "control flow"}}

زمانی که برنامه شما بیش از یک ((دستور)) دارد، دستورها مثل خواندن یک داستان، از بالا به پایین اجرا می شوند. به عنوان مثال، این برنامه دو دستور دارد. اولین دستور از کاربر درخواست می‌کند که عددی را وارد نماید و دومین که پس از آن اجرا می‌شود، ((مربع)) عدد وارد شده را نشان می دهد.

```
let theNumber = Number(prompt("Pick a number"));
console.log("Your number is the square root of " +
            theNumber * theNumber);
```

{{index [number, "conversion to"], "type coercion", "Number function", "String function", "Boolean function", [Boolean, "conversion to"]}}

تابع `Number` مقدار ورودی اش را به عدد تبدیل می‌کند. ما به این تبدیل نیاز داریم چرا که خروجی تابع `prompt` از جنس رشته است و ما به دنبال عدد هستیم. توابع مشابهی به نام‌های `String` و `Boolean` وجود دارند که مقادیر را به نوع خودشان تبدیل می کنند.

در اینجا شمایی ابتدایی از چگونگی جریان کنترل  خطی مستقیم نمایش داده شده است.

{{figure {url: "img/controlflow-straight.svg", alt: "Trivial control flow", width: "4cm"}}}

## اجرای شرطی

{{index Boolean, ["control flow", conditional]}}

همه‌ی برنامه‌ها از جنس خطی و مستقیم نیستند. مثلا ممکن است بخواهیم یک راه دیگر هم در برنامه در نظر بگیریم که برنامه با توجه به شرایطی که در دست دارد راه مناسب را انتخاب کند. به این کار _((اجرای شرطی))_ می گویند.

{{figure {url: "img/controlflow-if.svg", alt: "Conditional control flow",width: "4cm"}}}

{{index [syntax, statement], "Number function", "if keyword"}}

در جاوااسکریپت اجرای شرطی را با کلمه کلیدی `if` پیاده سازی می کنند. در یک مورد ساده، ما قصد داریم که قطعه کدی فقط در صورتی اجرا شود که شرط خاصی برقرار باشد. به عنوان نمونه، در برنامه‌ی قبل، ممکن است بخواهیم که مربع ورودی را تنها زمانی نشان دهیم که ورودی از جنس عدد باشد.

```{test: wrap}
let theNumber = Number(prompt("Pick a number"));
if (!Number.isNaN(theNumber)) {
  console.log("Your number is the square root of " +
              theNumber * theNumber);
}
```
با این تغییر، اگر رشته‌ی “parrot” را وارد کنید، چیزی به عنوان خروجی نشان داده نخواهد شد.

{{index [parentheses, statement]}}

کلمه کلیدی `if` براساس مقدار یک عبارت بولی، دستوری را اجرا یا از آن صرف نظر می‌کند. این عبارت بولی که مبنای تصمیم گیری است درست بعد از کلمه کلیدی، در داخل پرانتز نوشته می‌شود و در ادامه عبارتی می آید که قرار است اجرا شود.

{{index "Number.isNaN function"}}

تابع `Number.isNaN` یک تابع استاندارد جاوااسکریپت است که زمانی مقدار `true` را برمی گرداند که آرگومان ورودی آن از نوع `NaN` باشد. اگر رشته‌ای که به تابع `Number` داده می‌شود، بیانگر یک عدد معتبر نباشد، این تابع مقدار `NaN` را برمی‌گرداند. بنابراین، معنای عبارت شرطی این‌گونه می‌شود: “اگر `theNumber` از جنس غیر عدد نباشد (عددی باشد) فلان کار را انجام بده”.

{{index grouping, "{} (block)", [braces, "block"]}}

در این مثال دستوری که در خط بعد از `if`  قرار دارد توسط کروشه‌های مجعد محصور شده است (`{` و
`}`). از کروشه ها می توان برای گروه‌بندی دستورات متعدد به عنوان یک دستور استفاده کرد که به آن _((بلاک))_ گفته می‌شود. در مثال فوق می توانستید که کروشه‌ها را حذف کنید چون فقط یک دستور داشتید اما برای دوری از ابهام گذاشتن یا نگذاشتن آن‌ها، بیشتر برنامه نویسان جاوااسکریپت از کروشه‌ها در مواردی شبیه به این هم استفاده می کنند. ما هم در این کتاب از همین عرف استفاده می کنیم مگر در بعضی موارد که قصد داریم کلا دستور در یک خط باشد.

```
if (1 + 1 == 2) console.log("It's true");
// → It's true
```

{{index "else keyword"}}

همیشه اینطور نیست که برنامه در صورت true بودن شرط اجرا شود، بلکه گاهی عکس این مطلب اتفاق می افتد. این مسیر جانبی در دیاگرام با پیکان دوم نمایش داده شده است. استفاده از کلمه کلیدی `else` به همراه `if` این امکان را به ما  می‌دهد تا دو مسیر اجرایی متفاوت تعریف کنیم.


```{test: wrap}
let theNumber = Number(prompt("Pick a number"));
if (!Number.isNaN(theNumber)) {
  console.log("Your number is the square root of " +
              theNumber * theNumber);
} else {
  console.log("Hey. Why didn't you give me a number?");
}
```

{{index ["if keyword", chaining]}}

اگر بیش از دو مسیر برای انتخاب داشتیم، می توان از چندین جفت `if`/`else` که با هم زنجیر شده اند استفاده کرد. به مثال توجه کنید:

```
let num = Number(prompt("Pick a number"));

if (num < 10) {
  console.log("Small");
} else if (num < 100) {
  console.log("Medium");
} else {
  console.log("Large");
}
```

برنامه در ابتدا بررسی می‌کند که آیا `num` از 10 مقدارش کم تر است یا خیر. اگر کمتر بود، به سراغ آن شاخه از کد می رود و `"Small"` را نشان می دهد و کار تمام است. اگر شرط دوم (<bdo>`< 100`</bdo>) برقرار بود، به این معنا است که عدد بین 10 و 100 است که در این صورت `"Medium"` نمایش داده می‌شود. اگر هیچ کدام نبود،  دومین و آخرین `else` انتخاب می‌شود.

نمودار برنامه بالا چیزی شبیه عکس زیر خواهد بود.

{{figure {url: "img/controlflow-nested-if.svg", alt: "Nested if control flow", width: "4cm"}}}

{{id loops}}
## while و do loops

برنامه ای را در نظر بگیرید که همه‌ی ((اعداد زوج)) بین 0 و 12 را چاپ می‌کند. یکی از راه های نوشتن این برنامه به شکل زیر است:

```
console.log(0);
console.log(2);
console.log(4);
console.log(6);
console.log(8);
console.log(10);
console.log(12);
```

{{index ["control flow", loop]}}

این برنامه کار خواهد کرد اما ایده‌ی اینکه اصلا برنامه‌ای نوشته می‌شود این است که که یک وظیفه، _کمتر_ کار ببرد نه بیشتر. اگر ما بخواهیم تمام اعداد زوج کوچکتر از 1000 را چاپ کنیم، روش قبلی دیگر عملی نیست. چیزی که لازم داریم روشی است که بتوان با آن کدهایی را تکرار کرد. این شکل جریان کنترل را _loop_ یا _حلقه_ می نامند.

{{figure {url: "img/controlflow-loop.svg", alt: "Loop control flow",width: "4cm"}}}

{{index [syntax, statement], "counter variable"}}

جریان کنترل حلقه‌ای به ما این امکان را می دهد که به نقطه‌ای در برنامه برگردیم، جایی که قبلا بوده ایم و آن را در حالت فعلی برنامه تکرار کنیم. اگر این امکان را با یک متغیر شمارشگر ترکیب کنیم، می توانیم کاری شبیه زیر را انجام دهیم:

```
let number = 0;
while (number <= 12) {
  console.log(number);
  number = number + 2;
}
// → 0
// → 2
//   … etcetera
```

{{index "while loop", Boolean, [parentheses, statement]}}

((دستوری)) که با کلمه کلیدی `while` شروع شود، یک حلقه ایجاد می‌کند. ساختار `while` بسیار شبیه به `if` است. کلمه `while` در ابتدا،‌ بعد از آن یک جفت پرانتز که در داخلش یک ((عبارت)) قرار می گیرد و بعد دستور نوشته می‌شود.
حلقه while، دستور مورد نظر را به صورت مداوم اجرا می‌کند البته تا زمانی که عبارت داخل پرانتز true ارزیابی شود. مقدار داخل پرانتز به نوع داده بولی تبدیل می‌شود و بعد ارزیابی می‌شود.

{{index [state, in binding], [binding, as state]}}

متغیر `number` در اینجا نشان می دهد که چگونه می توان از یک متغیر برای نگه‌داری پیشرفت یک برنامه استفاده کرد. هر بار که حلقه تکرار می‌شود، مقدار `number`  به اندازه‌ی 2 واحد از قبل بیشتر می‌شود. در ابتدای هر تکرار این عدد با عدد 12 مقایسه شده تا مشخص شود که آیا به پایان اجرای برنامه رسیده ایم یا خیر.

{{index exponentiation}}

به عنوان یک مثال کاربردی، اکنون می توانیم برنامه ای بنویسیم که مقدار 2^10^ را محاسبه کند و نمایش دهد. از دو متغیر استفاده خواهیم کرد: یکی برای نگه داشتن نتیجه محاسبه و دیگری برای شمردن تعداد دفعاتی که نتیجه را در 2 ضرب کرده ایم. حلقه بررسی می‌کند که متغیر دوم به 10 رسیده باشد که در غیر این صورت هر دوی متغیرها را به روز رسانی کند.

```
let result = 1;
let counter = 0;
while (counter < 10) {
  result = result * 2;
  counter = counter + 1;
}
console.log(result);
// → 1024
```

می توانستیم متغیر شمارنده‌ی counter را از عدد `1` شروع کنیم که در این صورت شرط به صورت <bdo>`<= 10`</bdo> بررسی می‌شود. به دلایلی که در [فصل
?](data#array_indexing) روشن خواهد شد، بهتر است که عادت کنیم تا از 0 بشماریم.


{{index "loop body", "do loop", ["control flow", loop]}}

حلقه `do` یک ساختار کنترلی  شبیه به حلقه‌ی `while` است. تفاوت فقط در یک چیز است: یک حلقه‌ی `do` حداقل بدنه‌اش را یک بار اجرا می‌کند و بررسی شرط توقف را بعد از اولین اجرا انجام می دهد. برای نشان دادن این ویژگی، قسمت بررسی شرط، بعد از بدنه‌ی حلقه نوشته می‌شود:

```
let yourName;
do {
  yourName = prompt("Who are you?");
} while (!yourName);
console.log(yourName);
```

{{index [Boolean, "conversion to"], "! operator"}}

این برنامه شما را وادار خواهد کرد که حتما نامی را وارد نمایید. این درخواست آن قدر پرسیده خواهد شد تا بالاخره چیزی غیر از رشته‌ی خالی را دریافت کند. افزودن عملگر `!` باعث می‌شود که یک مقدار قبل از منفی شدن به نوع بولی تبدیل شود و می دانیم که تمام رشته‌ها به جز `""` به `true` تبدیل می شوند. این بدین معنا است که حلقه تا زمانی که نامی غیر تهی وارد نکنید اجرا  می‌شود.

## ایجاد تورفتگی در کدها

{{index [code, "structure of"], [whitespace, indentation], "programming style"}}

همان طور که در مثال‌ها مشاهده کرده اید، در ابتدای دستوراتی که بخشی از دستورات بزرگ‌تر هستند، فضاهای خالی قرار داده ام. در جاوااسکریپت، این فضاها ضروری نیستند – کامپیوتر برنامه را بدون آن ها به خوبی قبول می‌کند. در واقع، حتی شکستن خطوط در برنامه ها اختیاری است. اگر دوست داشته باشید می توانید برنامه‌ای را در یک خط بلند بنویسید.

نقش ((تورفتگی‌ها)) در ((بلاک‌ها))، نمایان سازی ساختار کد است. هنگام کدنویسی گاهی بلاک‌های جدید درون بلاک‌های دیگر قرار می گیرند و پیدا کردن پایان و شروع بلاک ها سخت می‌شود. با ایجاد تورفتگی مناسب، شکل ظاهری برنامه خود بیانگر ساختار بلاک‌های درون آن خواهد بود.  من ترجیح می دهم که از دو فاصله برای هر بلاک باز استفاده کنم اما سلیقه‌ها متفاوت هستند بعضی افراد دوست دارند که از چهار فاصله استفاده کنند و بعضی ((کاراکتر تب)) را می پسندند. اما مساله مهم این است که برای هر بلاک جدید از میزان تورفتگی یکسانی استفاده کنیم.

```
if (false != true) {
  console.log("That makes sense.");
  if (1 < 2) {
    console.log("No surprise there.");
  }
}
```

اکثر برنامه های ((ویرایشگر)) کد [ (مثل ویرایشگر کد این کتاب)]{if
interactive}، تو رفتگی ها را به صورت خودکار و با اندازه مناسب ایجاد می کنند.

## حلقه‌های for

{{index [syntax, statement], "while loop", "counter variable"}}

خیلی از حلقه‌ها از الگویی که در مثال‌های `while` دیدیم پیروی می کنند. در ابتدا یک متغیر “شمارنده” ایجاد می‌شود تا پیشرفت حلقه را نگه‌داری کند. سپس حلقه‌ی `while` خواهد آمد که عبارت شرط آن معمولا مقدار شمارنده را بررسی می‌کند که به مرز خاصی رسیده باشد. در پایان بدنه‌ی حلقه، شمارنده به روز رسانی می‌شود تا پیشرفت برنامه پیگیری شود.

{{index "for loop", loop}}

چون این الگو بسیار رایج است، جاوااسکریپت و زبان های مشابه‌‌ آن روش کمی کوتاهتر و جامع تری را ارائه می دهند، حلقه `for`.

```
for (let number = 0; number <= 12; number = number + 2) {
  console.log(number);
}
// → 0
// → 2
//   … etcetera
```

{{index ["control flow", loop], state}}

برنامه‌ی بالا دقیقا معادل برنامه‌ی چاپ اعداد زوج [پیشین](program_structure#loops) است. تنها تفاوت این است که تمامی دستوراتی که به “وضعیت” برنامه ربط دارند، اکنون در یک گروه بعد از `for` قرار گرفته اند.

{{index [binding, as state], [parentheses, statement]}}

قسمت داخل پرانتز بعد از کلمه کلیدی `for` باید حتما دارای دو نقطه‌ویرگول باشند. قسمت قبل از نقطه‌ویرگول اول، حلقه را _مقداردهی اولیه_ می‌کند، که این کار معمولا با تعریف یک متغیر انجام می‌شود. قسمت دوم، عبارتی است که _بررسی_ می‌کند تا کی حلقه باید ادامه پیدا کند. بخش نهایی  وضعیت حلقه را بعد از هربار تکرار _به روز رسانی_ می‌کند. در بیشتر موارد، این روش از ساختار `while` کوتاهتر و سرراست تر است.

{{index exponentiation}}

در اینجا کدی را مشاهده می‌کنید که 2^10^ را محاسبه می‌کند البته با `for` به جای `while`:

```{test: wrap}
let result = 1;
for (let counter = 0; counter < 10; counter = counter + 1) {
  result = result * 2;
}
console.log(result);
// → 1024
```

## شکستن حلقه و خروج از آن

{{index [loop, "termination of"], "break keyword"}}

تنها راه به پایان رسیدن یک حلقه فقط تولید مقدار `false` توسط بخش شرط حلقه نیست. دستور خاصی به نام `break` وجود دارد که در صورت استفاده باعث می‌شود که بلافاصله برنامه از حلقه‌ی پیرامونش بیرون بیاید.

برنامه‌ی زیر چگونگی استفاده از `break` را نمایش می دهد. این برنامه، اولین عددی که بزرگتر و مساوی 20 است و همچنین قابل تقسیم بر 7 است را پیدا می‌کند.

```
for (let current = 20; ; current = current + 1) {
  if (current % 7 == 0) {
    console.log(current);
    break;
  }
}
// → 21
```

{{index "remainder operator", "% operator"}}

با استفاده از عملگر باقی مانده (`%`) می توان به راحتی بخش پذیری یک عدد بر عددی دیگر را امتحان کرد. اگر بخش پذیر باشد، باقی مانده‌ی تقسیم برابر صفر خواهد بود.

{{index "for loop"}}

ساختار `for` در این مثال، بخشی که پایان حلقه را بررسی می‌کند را ندارد. این بدین معنا است که حلقه هرگز متوقف نخواهد شد مگر اینکه دستور `break` در درون آن اجرا شود.

اگر آن دستور `break` را حذف کنید یا به طور اتفاقی  شرطی را بنویسید که همیشه مقدار `true` را تولید نماید، برنامه شما در یک _((حلقه‌ی بی‌نهایت))_ گیر خواهد افتاد. برنامه‌ای که در حلقه بی نهایت بیفتد، اجرای آن پایان نمی یابد، که معمولا چیز بدی است.

{{if interactive

اگر در مثال‌های موجود در صفحات آنلاین کتاب یک حلقه‌ی بی‌نهایت ایجاد کنید، پس از چند ثانیه، معمولا از شما پرسیده می‌شود که قصد ادامه اجرای اسکریپت را دارید یا خیر. اگر برنامه‌ متوقف نشود، مجبور خواهید شد تا برگه‌ای که در آن کار می‌کنید را ببندید، یا در بعضی مرورگرها، کل مرورگر را ببندید.

if}}

{{index "continue keyword"}}

کلمه‌ی کلیدی `continue` همانند `break` روی پیشروی حلقه تاثیر می گذارد. زمانی که `continue` در داخل بدنه حلقه اجرا شود، کنترل برنامه از بدنه خارج شده و به تکرار بعدی منتقل شده و ادامه می یابد.

## روش کوتاه به روزرسانی متغیرها

{{index assignment, "+= operator", "-= operator", "/= operator", "*= operator", [state, in binding], "side effect"}}

به‌خصوص در حلقه‌ها، معمولا لازم است تا یک متغیر را بر اساس مقدار قبلی‌اش به‌روز کنیم.

```{test: no}
counter = counter + 1;
```

جاوااسکریپت راه میانبری برای این کار دارد:

```{test: no}
counter += 1;
```
میانبرهای مشابهی برای دیگر عملگرها وجود دارد مثل <bdo>`result *= 2`</bdo> که مقدار متغیر `result` را دوبرابر می‌کند یا <bdo>`counter -= 1`</bdo> که مقدار count را کاهش می دهد.

با این روش می توانیم مثال شمارش اعداد را کمی کوتاه تر بنویسیم.

```
for (let number = 0; number <= 12; number += 2) {
  console.log(number);
}
```

{{index "++ operator", "-- operator"}}

برای <bdo>`counter += 1`</bdo> و <bdo>`counter -= 1`</bdo> معادل‌های کوتاهتری هم وجود دارد: <bdo>`counter++`</bdo> و<bdo>`counter--`</bdo>.

## تصمیم گیری بر اساس یک مقدار به کمک switch

{{index [syntax, statement], "conditional execution", dispatch, ["if keyword", chaining]}}

کدهایی شبیه کد زیر بسیار رایج هستند:

```{test: no}
if (x == "value1") action1();
else if (x == "value2") action2();
else if (x == "value3") action3();
else defaultAction();
```

{{index "colon character", "switch keyword"}}

ساختاری به نام `switch` وجود دارد که در مواردی شبیه بالا خواناتر و سرراست تر است. متاسفانه، سبکی که جاوااسکریپت برای این ساختار استفاده می‌کند ( که از زبان‌های شبیه C/Java گرفته شده است) کمی بدقواره است – زنجیره‌ای از دستورات `if` ممکن است زیباتر به نظر بیاید. به مثال توجه فرمایید:

```
switch (prompt("What is the weather like?")) {
  case "rainy":
    console.log("Remember to bring an umbrella.");
    break;
  case "sunny":
    console.log("Dress lightly.");
  case "cloudy":
    console.log("Go outside.");
    break;
  default:
    console.log("Unknown weather type!");
    break;
}
```

{{index fallthrough, "break keyword", "case keyword", "default keyword"}}

می توانید هر تعداد دلخواه برچسب `case` درون یک بلاک `switch` قرار دهید. برنامه با توجه به مقداری که به `switch` داده می‌شود برچسب متناظر را انتخاب کرده و به آن قسمت منتقل می‌شود یا اگر موردی پیدا نشود قسمت `default` را اجرا می‌کند. پس از انتخاب برچسب، دستورات آن اجرا می شوند حتی دستوراتی که زیر برچسب دیگری قرار دارند تا زمانیکه برنامه به دستور `break` برسد. در بعضی موارد، مانند case مربوط به `"sunny"` در مثال بالا، این امکان را می توان برای به اشتراک گذاری کدهایی بین case ها استفاده کرد ( برنامه، رفتن به بیرون شهر را برای هر دو هوای ابری و آفتابی پیشنهاد می دهد). اما حواستان باشد: خیلی ساده امکان دارد `break` فراموش شود که باعث می‌شود کدهایی اجرا شوند که مورد نظر شما نبوده اند.

## استفاده از حروف بزرگ

{{index capitalization, [binding, naming], [whitespace, syntax]}}

در نام متغیرها  نمی توان از فاصله (فضای خالی) استفاده کرد اما اغلب، استفاده از چند واژه برای شرح محتوای متغیر، مفید است. اینکه از چه شیوه‌ای برای نوشتن نام متغیرهای چند کلمه ای استفاده می‌کنید بستگی به سلیقه شما دارد:

```{lang: null}
fuzzylittleturtle
fuzzy_little_turtle
FuzzyLittleTurtle
fuzzyLittleTurtle
```

{{index "camel case", "programming style", "underscore character"}}

خواندن سبک اول می‌تواند سخت باشد. شخصا، روش استفاده از زیرخط (underscore) را می پسندم اگرچه تایپ آن کمی مشکل تر است. توابع ((استاندارد)) جاوااسکریپت و بیشتر برنامه نویسان جاوااسکریپت از روش آخر استفاده می کنند – به جز کلمه‌ی اول دیگر کلمات را با حروف بزرگ شروع می کنند. می توان به راحتی به یکی از این روش ها عادت کرد. کدنویسی با سبک‌های نامگذاری متفاوت، مشکلاتی در خوانایی کد ایجاد می‌کند، بنابراین ما فقط از یک سبک و آن هم سبک آخر استفاده خواهیم کرد.

{{index "Number function", constructor}}

در موارد کمی، مثل تابع `Number` حرف اول متغیر به صورت بزرگ نوشته شده است. این کار برای نشانه‌گذاری این تابع به عنوان یک تابع سازنده است. اینکه یک تابع سازنده چیست در [فصل
?](object#constructors) روشن خواهد شد. فعلا نکته مهم این است که این عدم ((یکپارچگی)) در این گونه موارد شما را ناراحت نکند.

## توضیحات

{{index readability}}

معمولا کدهای اصلی برنامه نمی‌توانند تمام اطلاعاتی را که می خواهید افراد دیگر با دیدن کد‌های شما متوجه آن بشوند را منتقل کنند. یا این کار را به شکلی رمزآلود و گنگ انجام می دهند که دیگران ممکن است از آن آگاه نشوند. گاهی هم ممکن است بخواهید تا نظرات مرتبطی را به عنوان بخشی از برنامه به کد‌هایتان اضافه کنید. اینجاست که _((توضیحات))_ به کار می آیند.

{{index "slash character", "line comment"}}

یک توضیح، متنی است که بخشی از برنامه محسوب می‌شود اما کامپیوتر آن را نادیده می گیرد. جاوااسکریپت دو راه برای نوشتن توضیحات دارد. برای نوشتن توضیحات تک-خطی ، می توانید از دو کاراکتر اسلش (`//`) در ابتدای توضیح استفاده کنید.

```{test: no}
let accountBalance = calculateBalance(account);
// It's a green hollow where a river sings
accountBalance.adjust();
// Madly catching white tatters in the grass.
let report = new Report();
// Where the sun on the proud mountain rings:
addToReport(accountBalance, report);
// It's a little valley, foaming like light in a glass.
```

{{index "block comment"}}

توضیحی که با `//` مشخص شده باشد فقط تا پایان همان خط در نظر گرفته می‌شود. متنی که بین <bdo>`/*`</bdo> و <bdo>`*/`</bdo> محصور شده باشد به طور کامل و بدون توجه به اینکه حاوی چند خط باشد، به عنوان توضیح در نظر گرفته می‌شود. این ویژگی برای افزودن بلاک‌های اطلاعات درباره‌ی یک فایل یا بخشی از برنامه استفاده می‌شود.

```
/*
  I first found this number scrawled on the back of an old notebook.
  Since then, it has often dropped by, showing up in phone numbers
  and the serial numbers of products that I've bought. It obviously
  likes me, so I've decided to keep it.
*/
const myNumber = 11213;
```

## خلاصه

اکنون شما می دانید که یک برنامه از مجموعه ای از دستورات ساخته می‌شود، که خود آن‌ها نیز گاهی حاوی دستورات بیشتری می‌باشند. دستورات حاوی عبارت‌ها هستند که خود این عبارت‌ها نیز می توانند از عبارت‌های کوتاهتری تشکیل شده باشند.

قرار دادن دستورات یکی پس از دیگری، برنامه ای را می سازد که از بالا به پایین به ترتیب اجرا می‌شود. می توان این ترتیب جریان کنترل را با استفاده از دستورات شرطی ( `if`, `else` و `switch`) و حلقه‌ها (`while`, `do`, و `for`)  به هم زد.

متغیرها را می توان برای دسته بندی بخشی از داده‌ها تحت یک نام استفاده کرد. همچنین آن‌ها برای حفظ و پیگیری حالت فعلی برنامه‌ی شما مفید می‌باشند. محیط اجرایی مجموعه‌ای از انتساب‌ها (متغیر‌ها) است که قبلا تعریف شده است. سیستم‌های جاوااسکریپت همیشه تعدادی متغیر استاندارد مفید را در محیط شما تعبیه می کنند.

توابع مقدارهایی ویژه هستند که بخشی از برنامه را در درون خود نگه داری می کنند. می توانید آن‌ها را با نوشتن <bdo>`functionName(argument1, argument2)`</bdo> فراخوانی کنید. این گونه فراخوانی کردن یک تابع، یک نوع عبارت محسوب می‌شود که می‌تواند مقداری را هم تولید کند.

## تمرین‌ها

{{index exercises}}

اگر مطمئن نیستید که چگونه راه حل‌هایی را که برای تمرین ها ارائه می دهید آزمایش و اجرا کنید، به [مقدمه](intro) رجوع کنید.

هر تمرین با یک شرح مساله شروع می‌شود. آن را بخوانید و سعی کنید آن را حل کنید. اگر در حل مساله به مشکل برخورد کردید، به قسمت “راهنمایی” که در انتهای هر تمرین قرار گرفته است است رجوع کنید. راه حل کامل برای تمرین‌ها در داخل این کتاب گنجانده نشده است،‌ اما می توانید آن ها را در  [_https://eloquentjavascript.net/code_](https://eloquentjavascript.net/code#2) بیابید. اگر واقعا می خواهید که از تمرین‌ها چیزی بیاموزید، فقط زمانی به سراغ راه حل ها بروید که مساله را حل نموده اید یا حداقل به اندازه کافی تلاش و زمان صرف حل آن کرده باشید که کمی احساس سردرد داشته باشید.

### حلقه و مثلث

{{index "triangle (exercise)"}}

حلقه‌ای را پیاده سازی کنید که هفت بار تابع `console.log` را فراخوانی کرده و مثلث زیر را تولید کند:

```{lang: null}
#
##
###
####
#####
######
#######
```

{{index [string, length]}}

دانستن این نکته که طول یک رشته را می توان با گذاشتن <bdo>`.length`</bdo> در انتهای آن بدست آورد شاید به دردتان بخورد.

```
let abc = "abc";
console.log(abc.length);
// → 3
```

{{if interactive

بیشتر تمرین‌ها به همراه‌ کدی می آیند که می توانید برای حل تمرین آن را ویرایش کنید. به یاد داشته باشید که برای ویرایش باید روی بلاک کد کلیک کنید.

```
// Your code here.
```
if}}

{{hint

{{index "triangle (exercise)"}}

می توانید با برنامه‌ای شروع کنید که اعداد 1 تا 7 را چاپ می‌کند، که با کمی دستکاری [کد مثال چاپ اعداد زوج](program_structure#loops) که در این فصل آمد به دست می آید. جایی که حلقه‌ی `for` را معرفی کردیم.

اکنون به شباهت بین اعداد و رشته‌هایی که از کاراکتر ‍‍`#` تشکیل شده اند توجه کنید. با افزودن 1، می‌شود از عدد 1 به عدد 2 رسید (<bdo>`+= 1`</bdo>). همین کار را می توان برای ایجاد `"##"` از `"#"` انجام داد (<bdo>`+= "#"`</bdo>). پس راه حل، شباهت زیادی به مثال چاپ اعداد دارد.

hint}}

### FizzBuzz

{{index "FizzBuzz (exercise)", loop, "conditional execution"}}

برنامه ای بنویسید که با استفاده از `console.log` تمامی اعداد بین 1 و 100 را چاپ نماید با دو استثنا. برای اعدادی که بر 3 بخش پذیرند به جای عدد عبارت`"Fizz"`، و برای اعدادی که بر 5 بخش پذیرند (نه بر 3)، مقدار `"Buzz"` را چاپ نماید.

وقتی برنامه شما موارد بالا را به درستی انجام داد، آن را تغییر داده تا مقدار `"FizzBuzz"` را برای اعدادی که بر 3 و 5 به طور همزمان بخش پذیرند چاپ کند ( برنامه همچنان باید `"Fizz"` و `"Buzz"` را برای اعدادی که به هر یک بخش پذیرند را چاپ کند).

(این مساله در واقع یکی از سوالات مصاحبه شغلی است که ادعا شده که می‌تواند برای رد افرادی که مناسب برنامه نویسی نیستند استفاده شود. بنابراین اگر شما آن را حل کردید، پس ارزش شما در بازار کار بالاتر رفته‌ است.  )

{{if interactive
```
// Your code here.
```
if}}

{{hint

{{index "FizzBuzz (exercise)", "remainder operator", "% operator"}}

حرکت بین اعدا به وضوح به حلقه‌ها مربوط می‌شود و انتخاب گزینه برای خروجی، به اجرای شرطی ارتباط پیدا می‌کند.  ترفند استفاده از عملگر باقی‌مانده (`%`) برای چک کردن تقسیم پذیر بودن یک عدد بر دیگری را به خاطر بیاورید ( که باقی مانده آن صفر می شد.)

در نسخه‌ی اول، سه خروجی برای هر عدد ممکن است، بنابراین باید یک زنجیره‌ی <bdo>`if`/`else if`/`else`</bdo> ایجاد کنید.

{{index "|| operator", ["if keyword", chaining]}}

نسخه‌ی دوم این برنامه یک راه حل سرراست و یک راه حل زیرکانه دارد. راه حل ساده این است که یک شاخه‌ی شرط دیگر اضافه شود تا شرط داده شده به دقت بررسی شود. برای راه زیرکانه، رشته‌ای حاوی کلمه یا کلماتی بسازید که در صورت تطبیق عدد، رشته و در غیر این صورت عدد چاپ شود. می توان از عملگر `||` در اینجا به شکل خوبی استفاده کرد.

hint}}

### صفحه‌ی شطرنج

{{index "chessboard (exercise)", loop, [nesting, "of loops"], "newline character"}}

برنامه ای بنویسید که رشته‌ای را ایجاد می‌کند که نمایانگر یک صفحه‌ی 8×8 است. از کاراکتر خط جدید برای جداسازی خطوط استفاده کنید. در هر مکان از صفحه می توان فضای خالی (فاصله) یا کاراکتر "#" استفاده کرد. مجموع کاراکترها باید شبیه صفحه شطرنج باشند.

رشته‌ی تولیدی را اگر به تابع `console.log` بدهید باید چیزی شبیه شکل زیر را تولید کند:

```{lang: null}
 # # # #
# # # #
 # # # #
# # # #
 # # # #
# # # #
 # # # #
# # # #
```
بعد از ساختن قسمت اول و تولید الگوی بالا، اکنون متغیر <bdo>`size = 8`</bdo> را تعریف کنید و برنامه را طوری تغییر دهید که برای هر مقدار `size` به درستی کار کند و صفحه‌ای با آن طول و عرض تولید کند.

{{if interactive
```
// Your code here.
```
if}}

{{hint

{{index "chess board (exercise)"}}

با یک رشته‌ی خالی (`""`) می توانید ساخت رشته‌ی مورد نظر را شروع کنید و بعد به صورت مداوم کاراکتر‌ها را ضافه نمایید. یک کاراکتر خط جدید به صورت <bdo>`"\n"`</bdo> نوشته می‌شود.

{{index [nesting, "of loops"], [braces, "block"]}}

برای کار با دو ((بعد))، لازم است تا از یک ((حلقه)) درون حلقه‌ای دیگر استفاده کنید. پیرامون بدنه‌های هر دو حلقه، کروشه بگذارید تا شروع و پایان هر یک را گم نکنید. سعی کنید برای بدنه‌ها به خوبی تورفتگی ایجاد کنید. ترتیب قرارگیری حلقه‌ها باید براساس رشته‌ای که می‌سازیم باشد (خط به خط، چپ به راست، بالا به پایین). بنابراین حلقه‌ی بیرونی خطوط را پوشش می دهد و حلقه‌ی درونی کاراکترهای هر خط را تولید می‌کند.

{{index "counter variable", "remainder operator", "% operator"}}

به دو متغیر برای ردگیری پیشرفت برنامه نیاز خواهید داشت. برای دانستن اینکه در یک موقعیت آیا باید فضای خالی قرار دهید یا کاراکتر `#`، می توانید بررسی کنید که جمع دو شمارنده‌ مقداری زوج باشد (<bdo>`% 2`</bdo>).

پایان دادن یک خط با یک کاراکتر خط جدید (<bdo>`"\n"`</bdo>) باید بعد از اینکه هر خط ساخته شد اتفاق بیفتند، بنابراین این کار را بعد از حلقه‌ی درونی اما درون حلقه‌ی بیرونی انجام دهید.

hint}}