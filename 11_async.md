{{meta {load_files: ["code/crow-tech.js", "code/chapter/11_async.js"]}}}

# برنامه‌نویسی ناهمگام

{{quote {author: "لائودْزی", title: "دائو ده جینگ", chapter: true}

چه‌کسی می تواند زمانی که گل‌های آب ته‌نشین می‌شوند شکیبا باشد؟
چه‌کسی می تواند تا رسیدن لحظه‌ی عمل مناسب بی‌حرکت باقی‌ بماند؟

quote}}

{{index "Laozi"}}

{{figure {url: "img/chapter_picture_11.jpg", alt: "Picture of two crows on a branch", chapter: framed}}}

بخش مرکزی یک کامپیوتر، بخشی که گام‌های اجرای برنامه‌ی ما را بر‌می‌دارد،
_پردازشگر_ نامیده می￼ شود. برنامه‌هایی که تا کنون دیده‌ایم از نوعی بوده اند که
پردازشگر را تا وقتی که کارشان تمام شود، مشغول نگه می دارند. سرعت اجرا در چیزی مثل
یک حلقه که با اعداد سر و کار دارد به میزان زیادی به سرعت پردازشگر ارتباط دارد.

{{index [memory, speed], [network, speed]}}

اما خیلی از برنامه‌ها، با چیزهایی غیر از پردازشگر تعامل دارند. به عنوان مثال، ممکن
است با کامپیوتری در یک شبکه تعامل داشته باشند یا داده‌ها را از دیسک سخت بخوانند –
که خیلی کندتر از گرفتن آن ها از حافظه‌ی اصلی است.

زمانی که اتفاقی این چنینی می افتد، بی کار گذاشتن پردازشگر کار نادرستی است- ممکن
است کارهای دیگری وجود داشته باشد که بتوان در آن حین انجام داد. این کار تا حدی
توسط سیستم عامل مدیریت می شود که پردازشگر را بین برنامه‌های متعددی که در حال
اجرا هستند بکار می گیرد. اما در مواقعی که می‌خواهیم یک برنامه‌ی واحد بتواند در هنگام
انتظار برای یک درخواست شبکه به اجرا و پیش‌رفت خود ادامه دهد، از سیستم‌عامل کمکی بر نمی‌آید.

## ناهمگامی

{{index "synchronous programming"}}

در یک مدل برنامه‌نویسی _همگام،_ همه چیز یک به یک اتفاق می افتد. زمانی که تابعی
را فراخوانی می کنید که عهده‌دار اجرای کاری طولانی است، تنها بعد از اتمام آن کار و
برگرداندن نتیجه‌ی تابع، کنترل به برنامه‌ برمی‌گردد. در حین اجرای تابع، برنامه‌ی
شما متوقف خواهد ماند.

{{index "asynchronous programming"}}

در مدل _ناهمگام_ می توان چندین کار را در یک زمان انجام داد. زمانی که کاری را شروع
می کنید، برنامه‌ی شما به اجرا ادامه خواهد داد. زمانی که آن کار تمام می شود،
برنامه خبردار شده و به نتایج دست خواهد یافت (به عنوان مثال می توان به خواندن
اطلاعات از دیسک سخت اشاره کرد).

می توان برنامه نویسی همگام و ناهمگام را با یک مثال کوچک مقایسه کرد: برنامه‌ای
که از دو منبع در شبکه، اطلاعاتی دریافت می کند و بعد نتایج را با هم ترکیب می کند.

{{index "synchronous programming"}}

در یک محیط همگام، جایی که درخواست فقط زمانی برمی گردد که کارش را تمام کرده باشد،
آسان ترین روش انجام این کار ارسال درخواست ها یکی پس از دیگری است. مشکل این روش
این است که درخواست دوم زمانی شروع می شود که درخواست اول تمام شده باشد. جمع
زمانی که صرف می شود حداقل برابر است با مجموع زمان پاسخ‌های درخواست ها.

{{index parallelism}}

راه حل این مسئله، در یک سیستم همگام، استفاده از نخ‌های (threads) اضافی کنترل
است. یک _thread_ یک برنامه‌ی دیگر است که در حال اجرا است که اجرای آن ممکن است
توسط سیستم عامل بین برنامه‌های دیگر قرار گیرد – چون بیشتر کامپیوترهای مدرن دارای
چندین پردازشگر هستند، چندین thread را می توان در یک آن روی پردازشگرها اجرا کرد.
یک thread دیگر می تواند درخواست دوم را شروع کند و سپس هر دوی thread ها￼ منتظر
نتیجه‌ی درخواستشان می مانند که بعد از آن دوباره همگام شده و نتایج را باهم ترکیب
می کنند.

{{index CPU, blocking, "asynchronous programming", timeline, "callback function"}}

در نمودار پیش رو، خطوط درشت نمایانگر زمانی است که برنامه سپری می کند تا در حالت
نرمال اجرا شود، و خطوط باریک نشانگر زمانی است که برای پاسخ شبکه صرف می شود. در
مدل همگام، زمانی که توسط شبکه گرفته می شود به عنوان بخشی از جدول زمانی برای
thread داده شده محسوب می شود. در مدل ناهمگام، شروع یک عملیات مرتبط با شبکه، به
طور مفهومی باعث ایجاد یک انشعاب در جدول زمانی می شود. برنامه‌ای که این انشعاب را
شروع کرده است به اجرای خود ادامی می دهد، و آن عملیات به موازات آن انجام می شود
و وقتی پایان یافت برنامه را باخبر می کند.

{{figure {url: "img/control-io.svg", alt: "Control flow for synchronous and asynchronous programming",width: "8cm"}}}

{{index ["control flow", asynchronous], "asynchronous programming", verbosity}}

راه دیگری که می توان با آن تفاوت این دو را بیان کرد این است که در مدل همگام،
انتظار برای پایان درخواست‌ها به صورت ضمنی است در حالیکه در مدل ناهمگام صریح و تحت
کنترل ما می‌باشد.

ناهمگامی مثل چاقوی دولبه است. برای برنامه‌هایی که مناسب اجرای مستقیم خطی نیستند
کار را ساده تر می کند اما در عین حال می تواند برای برنامه هایی که به صورت مستقیم
خطی اجرا می شوند نامناسب باشد. در ادامه این فصل با راه‌هایی برای حل این ناهمگونی
آشنا خواهیم شد.

هر دو پلتفرم مهم برنامه نویسی جاوااسکریپت – مرورگرها و <bdo>Node.js</bdo> –
عملیاتی که ممکن است زمانگیر باشند را به صورت ناهمگام اجرا می کنند و از نخ‌ها
(threads) استفاده نمی کنند. به دلیل اینکه برنامه نویسی روی thread ها کار سختی
محسوب می شود (در این نوع برنامه نویسی درک کارکرد برنامه، به دلیل انجام چند کار
در آن واحد بسیار سخت‌تر می شود)، روش ناهمگام عموما چیز خوبی محسوب می شود.

## فناوری کلاغ‌ها

خیلی از مردم می‌دانند که کلاغ‌ها پرنده‌هایی بسیار باهوش هستند. آن ها می
توانند از ابزار استفاده کنند، برای آینده برنامه ریزی کنند، چیزهایی را به خاطر
بسپارند و حتی این موارد را با هم به اشتراک بگذارند.

چیزی که بیشتر مردم از آن آگاه نیستند این است که کلاغ‌ها توانایی های زیادی دارند
که از دید ما مخفی می کنند. یک فرد مشهور (و کمی عجیب و غریب) متخصص کلاغ‌ها به من گفت
که فناوری کلاغ خیلی از فناوری انسان عقب نیست و آن ها در حال رسیدن به انسان
ها هستند.

به عنوان مثال، نهاد‌های زیادی بین کلاغ‌ها وجود دارد که توانایی ساخت وسایل
محاسباتی را دارند. این وسایل شبیه وسایل محاسباتی انسان‌ها، الکترونیکی نیستند
بلکه از رفتارهای حشراتی کوچک، گونه‌هایی نزدیک به موریانه￼ که یک رابطه‌ی همزیستی با
کلاغ ها توسعه داده اند، بهره برداری می کنند. کلاغ‌ها برایشان غذا فراهم می کنند و
در عوض حشرات کلنی‌های پیچیده‌ی آن ها را ساخته و بکار می اندازند، که به کمک
موجودات زنده‌ای که در درون آن ها زندگی می کنند، محاسبات را انجام می دهند.

این گونه کلنی‌ها معمولا در لانه‌های بزرگ و قدیمی قرار دارند. پرنده‌ها و حشرات
با همکاری هم شبکه‌ای از ساختارهای گلی پیازی‌شکل را می‌سازند و بین ترک‌های لانه
پنهان می کنند که در آن حشرات زندگی و کار خواهند کرد.

برای تعامل با دیگر وسایل،این ماشین‌ها از سیگنال‌های نور استفاده می کنند. کلاغ‌ها
قطعاتی از مواد انعکاسی را در ساقه‌های خاصی که برای ارتباط در نظر گرفته شده اند
جاسازی می کنند و حشرات آن ها را هدف قرار می دهند تا نور را به لانه‌ی دیگری
بتابانند و داده‌ها را به صورت دنباله‌ای از چشمک‌های کوتاه به رمز در می آورند. این
یعنی فقط لانه‌هایی که دارای یک ارتباط متصل بصری هستند می توانند با یکدیگر تعامل
کنند.

دوست متخصص کلاغ ما نقشه‌ای از شبکه‌ی لانه‌های کلاغ‌ها در روستای <bdo>Hières-sur-Amby</bdo>
قرار دارد، کشیده است که در حاشیه‌ی رودخانه‌ی Rhône قرار دارد. آن نقشه نشان می دهد
که لانه‌ها و ارتباطاتشان چگونه است:

{{figure {url: "img/Hieres-sur-Amby.png", alt: "A network of crow nests in a small village"}}}

در نمونه‌ای شگفت‌انگیز از تکامل همگرا، کامپیوترهای کلاغ‌ها، جاوااسکریپت را اجرا می کنند. در این فصل قرار است بعضی از قابلیت‌های پایه‌ای شبکه را برایشان برنامه نویسی کنیم.


## callbacks - فراخوان برگشتی

{{indexsee [function, callback], "callback function"}}

یکی از راه‌های برنامه نویسی ناهمگام این است توابعی که یک کار زمانگیر را انجام می
دهند یک آرگومان اضافی دریافت کنند، یک تابع callback. تابع اصلی اجرا شده و پایان
می پذیرد بعد تابع callback با نتایج دریافتی از تابع اصلی فراخوانی می گردد.

{{index "setTimeout function", waiting}}

به عنوان یک مثال، تابع `setTimeout`، که در <bdo>Node.js</bdo> و مرورگرها در دسترس است، به
اندازه‌ی هزارم ثانیه‌ ای که مشخص شده است منتظر می ماند و سپس یک تابع را فراخوانی
می کند.


```{test: no}
setTimeout(() => console.log("Tick"), 500);
```

این انتظار معمولا خیلی کاربردهای مهمی ندارد اما در مواقعی می تواند مفید باشد مثل
به روز رسانی یک انیمیشن یا بررسی اینکه چیزی بیش از زمان مشخصی طول کشیده باشد.

اجرای چندین عمل ناهمگام در یک ردیف با استفاده از توابع callback به این معنا است
که شما باید به ارسال توابع جدید برای ادامه‌ی محاسبه بعد از هر عمل ادامه دهید.

{{index "hard disk"}}

بیشتر کامپیوترهای لانه‌های کلاغ‌ها، دارای یک بافت ذخیره‌سازی بلند مدت می باشند،
جاییکه اطلاعات، درون شاخه‌ها حک می شوند و می توان آن ها را بعدا دوباره خواند. حک
کردن یا پیدا کردن یک بخش از اطلاعات زمانگیر است بنابراین رابط سیستم
ذخیره‌سازی بلند مدت، ناهمگام خواهد بود و از توابع callback استفاده خواهد شد.

بافت‌های ذخیره‌سازی، بخش‌های اطلاعات را که به صورت JSON درآمده اند را تحت
نام‌هایی ذخیره می کنند. یک کلاغ ممکن است اطلاعاتی در مورد مخفیگاه‌ غذاها را به عنوان <bdo>`"food caches"`</bdo> ذخیره کند، که می تواند دارای آرایه‌ای از
نام‌هایی باشد که به دیگر بخش‌های اطلاعات اشاره می نمایند، اطلاعاتی که مخفیگاه واقعی
را توصیف می کنند. برای جستجوی یک مخفیگاه غذا در بافت‌های ذخیره‌سازی لانه‌ی <bdo>Big Oak</bdo>،
یک کلاغ می تواند کدی مثل زیر را اجرا کند.

{{index "readStorage function"}}

```{includeCode: "top_lines: 1"}
import {bigOak} from "./crow-tech";

bigOak.readStorage("food caches", caches => {
  let firstCache = caches[0];
  bigOak.readStorage(firstCache, info => {
    console.log(info);
  });
});
```
(تمامی متغیرها و رشته‌ها از زبان کلاغی به زبان انگلیسی ترجمه شده اند.)

این سبک از برنامه نویسی شدنی است اما با هر بار عمل همگام، میزان تورفتگی اضافه
می شود ،چرا که به تابع دیگر نیاز خواهید داشت. برای انجام کارهای پیچیده‌تر ، مثل
انجام چند عمل در یک زمان واحد، این شیوه‌ی کدنویسی می تواند کمی بدقواره شود.

کامپیوترهای لانه‌ها طوری ساخته شده اند که بتوانند به وسیله‌ی جفت‌های
درخواست-پاسخ با هم ارتباط برقرار کنند. این یعنی یک لانه، پیامی را به لانه‌ی
دیگری ارسال می کند، که این لانه نیز بلافاصله پیامی را که حاوی تایید دریافت و
احتمالا شامل پاسخی به درخواست است برمی‌گرداند.

هر پیغام توسط یک _نوع_، برچسب گذاری می شود که تعیین کننده‌ی نحوه‌ی مدیریت آن می باشد. کد
ما می تواند توابعی را برای رسیدگی به انواع خاص، تعریف کند، و زمانی که درخواستی از
آن نوع آمد ، تابع رسیدگی‌کننده فراخوانی شده تا پاسخی را تولید کند.

{{index "crow-tech module", "send method"}}

رابطی که توسط ماژول <bdo>`"./crow-tech"`</bdo> صادر می شود، تابعی دارای callback
برای تعامل فراهم می کند. لانه‌ها دارای متدی به نام `send` هستند که درخواست‌ها را
ارسال می کند. این متد نام لانه‌ی مقصد، نوع درخواست و محتوای درخواست را به عنوان
سه آرگومان اول گرفته و آرگومان بعدی یک تابع است که زمانی که یک پاسخ دریافت می
شود، فراخوانی می شود.

```
bigOak.send("Cow Pasture", "note", "Let's caw loudly at 7PM",
            () => console.log("Note delivered."));
```

اما برای اینکه لانه‌ها را قادر سازیم تا آن درخواست را دریافت کند، می‌بایست ابتدا
نوع درخواستی به نام `"note"` را تعریف کنیم. کدی که به این درخواست‌ها رسیدگی می کند
باید نه تنها بر روی کامپیوتر این لانه اجرا شود بلکه باید روی تمامی لانه‌هایی
که می توانند پیامی از این نوع را دریافت کنند اجرا شود. ما فرض می کنیم که کلاغی
پرواز کرده و کد ما را روی همه‌ی لانه‌ها نصب می کند.

{{index "defineRequestType function"}}

```{includeCode: true}
import {defineRequestType} from "./crow-tech";

defineRequestType("note", (nest, content, source, done) => {
  console.log(`${nest.name} received note: ${content}`);
  done();
});
```

تابع `defineRequestType` یک نوع درخواست جدید را تعریف می کند. در مثال، امکان
پشتیبانی از درخواست‌های `"note"` اضافه می می‌شود که در واقع تنها یک یادداشت را به لانه‌ی
داده شده ارسال می کند. پیاده‌سازی ما از <bdo>`console.log`</bdo> برای تایید رسیدن درخواست استفاده می کند. لانه‌ها دارای خاصیتی به نام `name` هستند که نامشان را نگه
داری می کند.

{{index "asynchronous programming"}}

آرگومان چهارمی که به تابع رسیدگی کننده داده می شود، `done`، یک تابع callback است
که باید زمانی که درخواست کارش تمام شد فراخوانی شود. اگر از مقدار بازگشتی (توسط return) از
تابع رسیدگی کننده به عنوان مقدار پاسخ استفاده کرده بودیم ، در این‌صورت
رسیدگی‌کننده‌ی درخواست نمی توانست خودش یک عمل ناهمگام را اجرا کند. تابعی که یک کار
ناهمگام را انجام می دهد نوعا قبل از انجام آن کار بر‌می‌گردد و برای اجرای تابع callback پس از انجام کار
تنظیم می شود. بنابراین ما نیاز به
مکانیزم‌هایی ناهمگام داریم – در این مثال، به یک تابع callback دیگر- تا وقتی که یک
پاسخ آماده بود، علامت بدهیم.

به شکلی، ناهمگامی مسری است. هر تابعی که یک تابع را فراخوانی کند که به صورت
ناهمگام عمل می کند، خودش باید ناهمگام باشد که می توان با استفاده از یک callback
یا مکانیزمی شبیه به آن باشد تا نتیجه‌اش را تحویل دهد. فراخوانی یک callback کمی
پیچیده تر و مشکل‌ساز تر است از برگرداندن یک مقدار به شکل ساده، بنابراین استفاده از این روش برای
ساختاردهی بخش‌های بزرگی از برنامه‌تان جالب نیست.

## Promise ها

اگر بتوان مفاهیم مجرد را به صورت مقدار‌ها نمایش داد، اغلب ساده تر می شوند. در
 رابطه با کارهای ناهمگام می توانید به جای تنظیم یک تابع برای فراخوانی در یک
 نقطه‌ی خاص در آینده، یک شیء را برگردانید که این رخداد آینده را نمایندگی کند.

{{index "Promise class", "asynchronous programming"}}

این دقیقا چیزی است که کلاس استاندارد `Promise` انجام می دهد. یک _promise_ یک عمل
ناهمگام است که در زمانی تکمیل می شود و مقداری را تولید می کند. می تواند هرکسی که
علاقمند باشد را در زمان آماده شدن مقدارش باخبر کند.

{{index "Promise.resolve function", "resolving (a promise)"}}

آسان ترین روش ایجاد یک promise فراخوانی <bdo>`Promise.resolve`</bdo> است. این تابع اطمینان
حاصل می کند که مقداری که به آن می دهید درون یک promise قرار می گیرد. اگر خودش
از قبل یک promise بود، برگردانده می  شود – در غیر این صورت، شما promise جدیدی
دریافت می کنید که با مقدار شما به عنوان نتیجه‌اش بلافاصله پایان می می‌پذیرد.

```
let fifteen = Promise.resolve(15);
fifteen.then(value => console.log(`Got ${value}`));
// → Got 15
```

{{index "then method"}}

برای گرفتن نتیجه‌ی یک promise، می توانید از متد `then` آن استفاده کنید. این متد
تابع callbackای را ثبت می کند که در هنگامی که promise به نتیجه رسید و مقداری را
تولید کرد، فراخوانی می شود. می توانید چندین تابع callback را به یک promise اضافه
کنید، و همه‌ی آن‌ها فراخوانی خواهند شد، حتی اگر آن‌ها را بعد از به نتیجه‌رسیدن
promise اضافه کنید.

اما این همه‌ی آن چیزی نیست که متد `then` انجام می دهد. این متد promise دیگری را
برمی‌گرداند، که مقداری که از تابع رسیدگی کننده برمی گردد را (resolve) را
نتیجه‌یابی می کند یا اگر یک promise را برگرداند، برای آن promise منتظر می ماند
سپس به حل و فصل نتیجه‌اش می پردازد.

خوب است که promiseها را به عنوان وسایلی که مقدارها را به درون فضای ناهمگام
انتقال می دهند تصور کنید. یک مقدار نرمال به سادگی وجود دارد. یک مقدار وعده داده
شده (promised value) مقداری است که ممکن است از قبل وجود داشته باشد یا در نقطه‌ای
در آینده ظاهر شود. محاسباتی که به عنوان promise تعریف می شوند روی این گونه
مقدارها عمل می کنند و همزمان با در دسترس قرار گرفتن مقدارها به اجرا در می آیند.

{{index "Promise class"}}

برای ایجاد یک promise، می‌توانید از `Promise` به عنوان یک سازنده استفاده کنید. رابط
آن کمی متفاوت است – سازنده یک تابع را به عنوان آرگومان می گیرد که آن را
بلافاصله فراخوانی می کند ، تابعی که می تواند برای نتیجه‌یابی promise استفاده شود.
به این صورت کار می کند، به جای اینکه به عنوان مثال با یک متد `resolve` کار کند، به
طوری که فقط کدی که promise را ایجاد کرده است می تواند آن را نتیجه‌یابی کند.

{{index "storage function"}}

این روشی است که می توانید برای ایجاد یک رابط مبتنی بر promise برای تابع
`readStorage` ایجاد کنید:

```{includeCode: "top_lines: 5"}
function storage(nest, name) {
  return new Promise(resolve => {
    nest.readStorage(name, result => resolve(result));
  });
}

storage(bigOak, "enemies")
  .then(value => console.log("Got", value));
```
این تابع ناهمگام یک مقدار معنادار را تولید می کند. این مزیت اصلی promise ها است
– آن ها استفاده از توابع ناهمگام را ساده می کنند. به جای اینکه مجبور باشیم
callbackهای متعددی ارسال کنیم، توابع مبتنی بر promise￼ شبیه توابع معمولی به نظر
می رسند: ورودی ها را به عنوان آرگومان می گیرند و خروجی شان را تولید می کنند.
تنها تفاوت این است که خروجی ممکن است هنوز در دسترس نباشد.

## شکست

{{index "exception handling"}}

محاسبات عادی جاوااسکریپت می توانند با شکست روبرو شده و یک استثنا را تولید کنند.
محاسبات ناهمگام هم اغلب به چیزی شبیه به آن نیاز دارند. ممکن است یک درخواست در
شبکه با شکست روبرو شود یا کدی که بخشی از یک محاسبه‌ی ناهمگام است استثنایی را
تولید کند.

{{index "callback function", error}}

یکی از حیاتی‌ترین مشکلاتی که در سبک مبتنی بر callback برنامه‌نویسی ناهمگام وجود
دارد این است که در این سبک، گزارش صحیح شکست‌ها به توابع callback بسیار دشوار
است.

یکی از راه حل های رایج برای آن این است که آرگومان اول callback برای مشخص کردن
شکست عمل در نظر می گیرند و دومین آرگومان، حاوی مقداری خواهد بود که در صورت موفقیت عمل،
تولید می شود. این گونه توابع callback باید همیشه بررسی کنند که آیا استثنایی
دریافت کرده اند یا خیر و اطمینان حاصل کنند که هر مشکلی که ایجاد می کنند، مانند
استثناهای تولیدی توسط توابعی که فراخوانی می‌کنند، مدیریت شده و به تابع
درستی داده می شود.

{{index "rejecting (a promise)", "resolving (a promise)", "then method"}}

promiseها این کار را ساده تر کرده اند. می توان آن ها را resolve (نتیجه یابی
) کرد (عمل با موفقیت به پایان رسیده) یا رد (reject) کرد (شکست خورده است). توابع
رسیدگی کننده به موفقیت (که با متد `then` ثبت شده اند) فقط زمانی فراخوانی می شوند
که عمل باموفقیت انجام شده باشد و rejectها به صورت خودکار به یک promise جدید
سپرده‌ می شوند که توسط `then` برگردانده می شود. و زمانی که یک تابع گرداننده (handler)
استثنا تولید می کند، این به طور خودکار سبب می شود که promise ای که توسط فراخوانی
متد thenاش تولید شده است رد بشود. بنابراین اگر یکی از عناصری که در زنجیره‌ی اعمال
ناهمگام قرار دارد با شکست روبرو شود، خروجی تمام زنجیره به عنوان “رد شده” یا rejected در نظر
گرفته می شود، و هیچ تابع گرداننده‌ی دیگری بعد از نقطه‌ای که با مشکل روبرو شده است
فراخوانی نمی شود.

{{index "Promise.reject function", "Promise class"}}

بسیار شبیه به نتیجه‌یابی یک promise که مقداری را فراهم می ساخت، رد شدن آن نیز
مقداری را فراهم می کند، که معمولا به عنوان دلیل رد شدن شناخته می شود. زمانی که
یک استثنا در یک تابع گرداننده باعث رد شدن می شود، مقدار استثنا به عنوان دلیل
استفاده می شود. به طور مشابه زمانی که یک گرداننده، یک promise را برمی گرداند که
رد شده است، این پذیرفته‌نشدن به درون promise بعدی جریان می یابد. تابعی به نام
<bdo>`Promise.reject`</bdo> وجود دارد که یک promise رد شده جدید بلافاصله ایجاد می کند.

{{index "catch method"}}

رای رسیدگی صریح به این گونه رد شدن‌ها، promise ها دارای متدی به نام `catch` هستند
که یک گرداننده را برای￼ فراخوانی در هنگام رد شدن ثبت می کند، شبیه به گرداننده‌های
`then` که در موارد یافتن نتیجه صحیح استفاده می شدند. از این لحاظ نیز بسیار شبیه
به `then` است که یک promise جدید برمی گرداند که در صورت نتیجه‌یابی بدون مشکل به نتیجه‌ی
promise اصلی منجر می شود و در غیر این صورت به نتیجه‌ی گرداننده‌ی `catch`. اگر یک گرداننده‌ی `catch`
خطایی تولید کند، promise جدید نیز رد می شود.

{{index "then method"}}

به عنوان یک راه خلاصه تر، متد `then` همچنین یک گرداننده‌ی عدم پذیرش نیز به عنوان
آرگومان دوم قبول می کند، بنابراین می توانید هر دوی گرداننده‌ها را با یک فراخوانی
متد ثبت کنید.

تابعی که به سازنده‌ی `Promise` ارسال می شود در کنار تابع موفقیت (resolve)
آرگومان دومی را دریافت می کند، که می تواند برای رد کردن promise جدید استفاده
شود.


زنجیره‌ی مقدارهای promise که با فراخوانی‌هایی که به `then` و `catch` زده شده است
تولید شده را می توان به عنوان یک خط لوله در طول مقدارهای ناهمگام یا حرکت‌های منجر
به شکست دانست. به دلیل این که این زنجیره به وسیله‌ی ثبت گرداننده‌ها تولید می شود،
هر پیوند دارای یک گرداننده‌ی موفقیت یا عدم پذیرش (یا هر دو) است که به آن ارتباط
دارد. گرداننده‌هایی که تطبیقی با نوع خروجی (موفقیت یا شکست) ندارند در نظر گرفته
نمی شوند. اما آن هایی که هماهنگ هستند فراخوانی می شوند و خروجی آن ها مشخص می
کند چه نوع مقداری در ادامه‌ خواهد آمد – موفقیت در زمانی که یک مقدار غیر promise
بر می گرداند، عدم پذیرش زمانی که یک استثنا تولید می شود، و خروجی یک promise
زمانی که یکی از آن ها را بر می گرداند.

```{test: no}
new Promise((_, reject) => reject(new Error("Fail")))
  .then(value => console.log("Handler 1"))
  .catch(reason => {
    console.log("Caught failure " + reason);
    return "nothing";
  })
  .then(value => console.log("Handler 2", value));
// → Caught failure Error: Fail
// → Handler 2 nothing
```

{{index "uncaught exception", "exception handling"}}

بسیار شبیه به یک استثنای مدیریت نشده که توسط محیط رسیدگی می شود ، محیط های
جاوااسکریپت می توانند تشخیص دهند در چه زمانی یک عدم موفقیت promise رسیدگی نشده
است و آن را به عنوان یک خطا گزارش خواهند داد.

## شبکه‌ها دشوار هستند

{{index [network, reliability]}}

گاهی اوقات، نور کافی برای سیستم انعکاس نور کلاغ‌ها برای انتقال سیگنال وجود ندارد،
یا چیزی مسیر سیگنال را مسدود کرده است. ممکن است سیگنالی فرستاده شود ولی هرگز
دریافت نشود.

{{index "send method", error, timeout}}

در این صورت، این باعث می شود که تابع callback ای که به متد `send` داده شده است
هرگز فراخوانی نشود، که احتمالا موجب توقف برنامه بدون هیچ گونه اعلام مشکل می شود.
خوب بود اگر بعد از یک دوره‌ی زمانی مشخص شده که پاسخی دریافت نشود، یک
درخواست به صورت خودکار منقضی می شد و یک شکست گزارش می شد.


اغلب، شکست های مربوط به ارسال به صورت تصادفی اتفاق می افتند، مانند بروز تداخل
بین چراغ جلوی یک خودرو با￼ سیگنال‌های نوری، و در این صورت فقط دوباره فرستان
درخواست مشکل را برطرف می کند. بنابراین هنگامی که هنوز در آن نقطه قرار داریم،
اجازه بدهید تابع درخواست را طوری تنظیم کنیم که به طور خودکار قبل از اینکه دست از کار بکشد چندین بار
درخواست را ارسال کند.


{{index "Promise class", "callback function", [interface, object]}}


و به دلیل اینکه قبول کرده ایم که promise ها مفید هستند، پس تابع درخواست را
تغییر می دهیم تا یک promise برگرداند. در رابطه با کاری که می توانند انجام دهند
تفاوتی بین callback ها و promise ها وجود‌ ندارد. توابع مبتنی بر callback را می توان
پوشاند به شکلی که رابطی promise گونه داشته باشند و همین طور برعکس.


حتی زمانی که یک درخواست و پاسخ آن با موفقیت تحویل داده می شوند، پاسخ ممکن است
نشانگر یک شکست باشد – به عنوان مثال، اگر درخواست تلاش کند که از نوع درخواستی
استفاده کند که تعریف نشده است یا گرداننده یک خطا تولید کند. برای پشتیبانی از
این، `send` و `defineRequestType` از قراردادی پیروی می کنند که قبل تر ذکر شد جاییکه
اولین آرگومان فرستاده شده با تابع callback، دلیل شکست خواهد بود، در صورت وجود
البته، و دومین آرگومان نتیجه‌ی واقعی خواهد بود.

این‌ها را می توان به وسیله‌ی یک پوشاننده (wrapper) به پذیرش و عدم پذیرش promise ترجمه کرد.

{{index "Timeout class", "request function", retry}}

```{includeCode: true}
class Timeout extends Error {}

function request(nest, target, type, content) {
  return new Promise((resolve, reject) => {
    let done = false;
    function attempt(n) {
      nest.send(target, type, content, (failed, value) => {
        done = true;
        if (failed) reject(failed);
        else resolve(value);
      });
      setTimeout(() => {
        if (done) return;
        else if (n < 3) attempt(n + 1);
        else reject(new Timeout("Timed out"));
      }, 250);
    }
    attempt(1);
  });
}
```

{{index "Promise class", "resolving (a promise)", "rejecting (a promise)"}}

به دلیل اینکه promise ها می توانند فقط یک بار موفق شوند (یا رد بشوند)، این روش
کار خواهد کرد. اولین باری که `resolve` یا `reject` فراخوانی می شوند، خروجی promise را
معین می کنند، و هر فراخوانی ای در بعد، مانند timeout که بعد از پایان درخواست می
رسد یا درخواستی که بعد از یک پایان یک درخواست دیگر برمی گردد، در نظر گرفته نمی
شوند.

{{index recursion}}

برای ساخت یک حلقه‌ی ناهمگام، برای تلاش‌های اضافی، لازم است تا از یک تابع بازگشتی
استفاده کنیم – یک حلقه‌ی معمولی امکان توقف و صبر برای یک عمل ناهمگام را فراهم نمی
کند. تابع `attemp` یک تلاش واحد برای ارسال یک درخواست ترتیب می دهد. همچنین یک زمان
انقضا تنظیم می کند، اگر پاسخی بعد از 250 هزارم ثانیه نیامد ، یا تلاش بعد را شروع
کند یا اگر این چهارمین تلاش بود ، promise را رد می‌کند و به عنوان دلیل عدم پذیرش هم
یک نمونه از `Timeout` را استفاده می‌کند.

{{index idempotence}}


تلاش مجدد هر یک چهارم ثانیه و توقف در صورت نیامدن پاسخ پس از گذشت یک ثانیه،
قطعاً تا حدودی دلخواه است. البته حتی ممکن است که درخواست دریافت شود اما تابع گرداننده
کند عمل کند که باعث شود عمل دریافت چندین بار صورت گیرد. ما توابع گرداننده‌ را طوری می نویسیم
که این مشکل را پوشش دهیم و پیغام‌های تکراری ضرری برای سیستم نداشته باشد.

به طور عمومی، قرار نیست که یک شبکه‌ی بی نقص در سطح جهانی را امروز بسازیم. اما قابل قبول
خواهد بود- کلاغ‌ها انتظارات خیلی بالایی در رابطه با محاسبات ندارند.

{{index "defineRequestType function", "requestType function"}}

برای اینکه خودمان را به طور کامل از callback ها رها کنیم، پیش‌تر خواهیم رفت و
همچنین یک پوشش برای تابع `defineRequestType` تعریف خواهیم کرد که به تابع گرداننده
اجازه بدهد تا یک promise یا مقداری ساده را برگرداند و آن را به callback برای ما
متصل کند.

```{includeCode: true}
function requestType(name, handler) {
  defineRequestType(name, (nest, content, source,
                           callback) => {
    try {
      Promise.resolve(handler(nest, content, source))
        .then(response => callback(null, response),
              failure => callback(failure));
    } catch (exception) {
      callback(exception);
    }
  });
}
```

{{index "Promise.resolve function"}}

<bdo>`Promise.resolve`</bdo> برای تبدیل مقدار بازگشتی از `handler` به یک promise استفاده می شود؛ اگر قبلا انجام نشده باشد.

{{index "try keyword", "callback function"}}

توجه داشته باشید فراخوانی به تابع `handler` بایستی درون یک بلاک `try` قرار می گرفت،
تا اطمینان حاصل شود هر استثنایی که تولید می کند مستقیما به تابع callback داده می
شود. این به خوبی سختی رسیدگی درست به خطاها در مدل callback های خام را نشان می
دهد – به راحتی می ممکن است مدیریت صحیح استثناها را فراموش کنیم؛ مانند بالا و
اگر این کار را انجام ندهید، شکست‌ها به callback درستی گزارش نمی شوند. در promise ها،
این کار را به طور خودکار انجام می می‌شود بنابراین کمتر خطاساز خواهند بود.

## مجموعه‌ای از promise ها

{{index "neighbors property", "ping request"}}

هر کامپیوتر لانه دارای آرایه‌ای از دیگر لانه‌ها می‌باشد که درون محدوده‌ی مخابره
قرار دارند و آن را در خاصیت `neighbors` آن ذخیره می کند. برای بررسی اینکه کدام
یک از آن ها در حال حاضر در دسترس هستند، می توانید تابعی بنویسید که تلاش کند تا
یک درخواست `“ping”` (درخواستی که فقط برای دریافت پاسخ ارسال می شود) را به هر یک از
لانه ها ارسال کند و مشاهده کنید کدام درخواست پاسخ داده می شود.

{{index "Promise.all function"}}

زمانی که با مجموعه‌ای از promise ها کار می کنید که در یک زمان یکسان اجرا می شوند،
تابع <bdo>`Promise.all`</bdo> می تواند مفید باشد. این تابع یک promise را برمی گرداند که برای
همه‌ی promise های درون آرایه صبر می کند تا به نتیجه برسند و بعد نتیجه را درون یک
آرایه از مقدارهایی که این promise ها تولید کرده اند می ریزد (به همان ترتیبی که
در آرایه‌ی اصلی آمده بودند). اگر یک promise رد شده باشد، نتیجه‌ی <bdo>`Promise.all`</bdo>
خودش نیز رد می شود.

```{includeCode: true}
requestType("ping", () => "pong");

function availableNeighbors(nest) {
  let requests = nest.neighbors.map(neighbor => {
    return request(nest, neighbor, "ping")
      .then(() => true, () => false);
  });
  return Promise.all(requests).then(result => {
    return nest.neighbors.filter((_, i) => result[i]);
  });
}
```

{{index "then method"}}

زمانی که یک همسایه در دسترس نیست، دوست نداریم که تمامی promise ترکیب شده با شکست
روبرو شود، در آن موقع ما هنوز چیزی نمی دانیم. بنابراین تابعی که بر روی مجموعه‌ی
همسایه‌ها اعمال شده است تا هر یک از￼ آن ها را به درخواست‌های promise تبدیل کند،
گرداننده‌هایی الصاق می کند تا درخواست های موفق `true` را تولید کنند و رد شده ها
`false` را برگردانند.

{{index "filter method", "map method", "some method"}}

در گرداننده‌ای که برای promise ترکیب شده در نظر گرفته شده است، `filter` برای حذف
آن عناصر از آرایه‌ی `neighbors` می‌باشد. عناصری که مقدار متناظرشان برابر با false می‌باشد.
این کار از این واقعیت بهره می برد که `filter` اندیس عنصر فعلی در آرایه‌ را به عنوان آرگومان
دومش به تابع فیلترش (مانند `map`، `some` یا دیگر توابع رده‌بالای آرایه‌ها که مشابه عمل می کنند) ارسال می کند.

## جریان سیل‌گونه در شبکه
این واقعیت که لانه‌ها فقط می توانند با همسایه‌هایشان ارتباط برقرار کنند در مفید
بودن این شبکه مانع ایجاد می کند.

برای رساندن اطلاعات به کل شبکه، یک راه حل این است که نوع درخواستی تنظیم شود که
به صورت خودکار به دیگر همسایه‌ها مخابره شود. این همسایه ها سپس آن اطلاعات
را به همسایه‌هایشان منتقل می کنند تا زمانی که کل شبکه پیام را گرفته باشد.

{{index "sendGossip function"}}

```{includeCode: true}
import {everywhere} from "./crow-tech";

everywhere(nest => {
  nest.state.gossip = [];
});

function sendGossip(nest, message, exceptFor = null) {
  nest.state.gossip.push(message);
  for (let neighbor of nest.neighbors) {
    if (neighbor == exceptFor) continue;
    request(nest, neighbor, "gossip", message);
  }
}

requestType("gossip", (nest, message, source) => {
  if (nest.state.gossip.includes(message)) return;
  console.log(`${nest.name} received gossip '${
               message}' from ${source}`);
  sendGossip(nest, message, source);
});
```

{{index "everywhere function", "gossip property"}}

برای جلوگیری از ارسال یک پیام یکسان در شبکه به صورت همیشگی، هر لانه آرایه‌ای از
رشته‌هایی که قبلا دیده شده اند را نگه داری می کند. برای تعریف این آرایه، از تابع
`everywhere` استفاده می کنیم – که کد را روی هر لانه اجرا می کند – برای افزودن یک
خاصیت به شیء state لانه، که جایی است که ما وضعیت محلی لانه را نگه داری خواهیم
کرد.

زمانی که یک لانه یک پیام تکراری را دریافت کند، که احتمالش جایی که
هر لانه پیام‌ها را ندید بازارسال می کند وجود دارد، از آن پیام صرف نظر می شود. اما زمانی که
پیامی جدید را دریافت می کند، آن پیام را با هیجان به همه‌ی لانه‌ها به جز لانه‌ای که
فرستنده‌ی پیام بوده است ارسال می کند.

این باعث می شود که شبیه به پخش شدن جوهر در آب، خبر جدیدی در شبکه پخش شود . حتی
زمانی که بعضی از ارتباطات در دسترس نیستند، اگر مسیر جایگزینی به یک لانه‌ی مشخص
وجود داشته باشد، خبر از آن طریق به آن لانه خواهد رسید.

{{index "flooding"}}

این سبک از ارتباطات شبکه‌ای را سیل‌گونه (flooding) می گویند – مانند سیل تمام شبکه
را با اطلاعات فرا‌ می‌گیرد تا این که همه‌ی گره ها را پوشش دهد.

{{if interactive

با فراخوانی `sendGossip` می توانیم جریان پیغام درون روستا را مشاهده کنیم.

```
sendGossip(bigOak, "Kids with airgun in the park");
```

if}}

## مسیردهی پیام

{{index efficiency}}

اگر یک گره بخواهد با یک گره‌ی مشخص دیگر ارتباط برقرار کند، سبک سیل‌گونه زیاد
بهینه نخواهد بود. مخصوصا زمانی که شبکه بزرگ باشد، که باعث می‌شود میزان زیادی مخابره
اطلاعات بدون کاربرد صورت گیرد.

{{index "routing"}}

یک راه حل جایگزین این است که برای پیام‌ها راهی در نظر گرفته شود تا از گره‌ای به
گره‌های دیگر بپرند تا به گره‌ی مقصد برسند. مشکل این روش این است که بایستی اطلاعاتی
در باره‌ی نقشه‌ی شبکه داشته باشیم. برای ارسال درخواستی به سمت یک گره دور، لازم است
بدانیم کدام لانه‌های همسایه پیام را به مقصد نزدیک تر می کنند. ارسال آن به سمتی
اشتباه مارا به هدف نمی‌رساند.

به دلیل اینکه هر لانه فقط همسایه‌های مجاورش را می‌شناسد، اطلاعات کافی برای محاسبه
یک مسیر را در دست ندارد. باید به شیوه‌ای اطلاعات این اتصالات را بین همه‌ی لانه‌ها
منتشر کنیم. ترجیحا به روشی که بتوان در آینده در آن تغییر ایجاد کرد مثلا زمانی‌که
که یک لانه متروکه می شود یا لانه‌ی جدیدی ساخته می شود.

{{index flooding}}

می توانیم دوباره به سراغ روش سیل‌گونه برویم، اما به جای
استفاده از آن برای بررسی دریافت یک پیام، اکنون بررسی می کنیم آیا مجموعه‌ی
همسایه‌ها برای یک گره‌ی مشخص با مجموعه‌ای که اکنون برای آن در دسترس داریم مطابقت
دارد یا خیر.

{{index "broadcastConnections function", "connections binding"}}

```{includeCode: true}
requestType("connections", (nest, {name, neighbors},
                            source) => {
  let connections = nest.state.connections;
  if (JSON.stringify(connections.get(name)) ==
      JSON.stringify(neighbors)) return;
  connections.set(name, neighbors);
  broadcastConnections(nest, name, source);
});

function broadcastConnections(nest, name, exceptFor = null) {
  for (let neighbor of nest.neighbors) {
    if (neighbor == exceptFor) continue;
    request(nest, neighbor, "connections", {
      name,
      neighbors: nest.state.connections.get(name)
    });
  }
}

everywhere(nest => {
  nest.state.connections = new Map;
  nest.state.connections.set(nest.name, nest.neighbors);
  broadcastConnections(nest, nest.name);
});
```

{{index JSON, "== operator"}}

در مقایسه از <bdo>`JSON.stringify`</bdo> استفاده می شود چرا که `==`، روی اشیاء و آرایه‌ها، فقط
زمانی true برمی گرداند که هر دو طرف دارای مقدار یکسانی باشند، که چیزی نیست که ما
در اینجا لازم داریم. مقایسه‌ی رشته‌های JSON جالب به نظر نمی رسد اما روشی موثر برای
مقایسه‌ی محتوای آن ها است.


گره‌ها بلافاصله شروع به مخابره‌ی اتصالاتشان می کنند، که باید به سرعت به هر لانه یک
نقشه از گراف فعلی شبکه را بدهد، مگر اینکه بعضی از لانه‌ها کلا در دسترس نباشند.

{{index pathfinding}}

یکی از کارهایی که در گراف‌ها می توان انجام داد پیدا کردن مسیر‌ها در آن‌ها است ،
همانطور که در [فصل ?](robot) دیدیم. اگر مسیری به سمت یک مقصد پیام داشته باشیم، می دانیم
از کدام جهت باید اقدام به ارسال آن کنیم.

{{index "findRoute function"}}

این تابع `findRoute`، که بسیار شباهت به تابع `findRoute` [فصل ?](robot#findRoute) دارد،
برای رسیدن به
یک گره مشخص شده در شبکه به جستجو می پردازد. اما به جای برگرداندن تمام مسیر، فقط
گام بعدی را برمی گرداند. لانه‌ی بعدی خودش، از اطلاعات فعلی اش در رابطه با شبکه
استفاده خواهد کرد و تصمیم می گیرد که کجا پیغام را بفرستد.

```{includeCode: true}
function findRoute(from, to, connections) {
  let work = [{at: from, via: null}];
  for (let i = 0; i < work.length; i++) {
    let {at, via} = work[i];
    for (let next of connections.get(at) || []) {
      if (next == to) return via;
      if (!work.some(w => w.at == next)) {
        work.push({at: next, via: via || next});
      }
    }
  }
  return null;
}
```

اکنون می توانیم تابعی بسازیم که می تواند پیغام‌ها را به نقاط دور ارسال کند. اگر
پیام مورد نظر مقصدش یک همسایه‌ی مجاور بود، به طور معمولی تحویل داده می شود. در
غیر این صورت، درون یک شیء قرار گرفته و به همسایه‌ای ارسال می شود که به هدف نزدیک
تر است، با استفاده از نوع درخواست `"route"` که باعث می شود آن همسایه نیز این
رفتار را تکرار کند.

{{index "routeRequest function"}}

```{includeCode: true}
function routeRequest(nest, target, type, content) {
  if (nest.neighbors.includes(target)) {
    return request(nest, target, type, content);
  } else {
    let via = findRoute(nest.name, target,
                        nest.state.connections);
    if (!via) throw new Error(`No route to ${target}`);
    return request(nest, via, "route",
                   {target, type, content});
  }
}

requestType("route", (nest, {target, type, content}) => {
  return routeRequest(nest, target, type, content);
});
```

{{if interactive

اکنون می‌توانیم پیامی به لانه‌ای که در برج کلیسا قرار دارد ارسال کنیم که چهار
گام در شبکه نیاز دارد.

```
routeRequest(bigOak, "Church Tower", "note",
             "Incoming jackdaws!");
```

if}}

{{index [network, abstraction], layering}}

تاکنون لایه‌های متعددی از قابلیت‌ها را روی یک سیستم ارتباطی اولیه ساخته ایم تا
استفاده از آن را راحت و سرراست کنیم. این مدل (البته ساده شده‌ی) خوبی از چگونگی
عملکرد شبکه‌های کامپیوتر در واقعیت است.

{{index error}}

یک خاصیت متمایز کننده در شبکه‌های کامپیوتری این است که آن ها قابل اتکا نیستند –
تجریدهایی که بر اساس آن‌ها انجام می‌ شود می توانند مفید باشند، اما شکست شبکه را نمی توان با آن‌ها پوشش داد. بنابراین برنامه‌نویسی تحت شبکه نوعا با
انتظار خرابی (failure) در شبکه و مدیریت آن سر و کار دارد.

## توابع Async

برای ذخیره‌ی اطلاعات مهم، کلاغ‌ها اطلاعات را بین لانه‌ها تکثیر می کنند. در این روش
، زمانی که یک شاهین یکی از لانه‌ها را از بین می برد، اطلاعات از بین نخواهند رفت.

برای بازیابی یک بخش از اطلاعات که در بافت موجود در خود لانه وجود ندارد، یک
کامپیوتر لانه ممکن است با لانه‌های تصادفی در شبکه ارتباط بگیرد تا اینکه آن
لانه‌ای که اطلاعات را دارد پیدا شود.

{{index "findInStorage function", "network function"}}

```{includeCode: true}
requestType("storage", (nest, name) => storage(nest, name));

function findInStorage(nest, name) {
  return storage(nest, name).then(found => {
    if (found != null) return found;
    else return findInRemoteStorage(nest, name);
  });
}

function network(nest) {
  return Array.from(nest.state.connections.keys());
}

function findInRemoteStorage(nest, name) {
  let sources = network(nest).filter(n => n != nest.name);
  function next() {
    if (sources.length == 0) {
      return Promise.reject(new Error("Not found"));
    } else {
      let source = sources[Math.floor(Math.random() *
                                      sources.length)];
      sources = sources.filter(n => n != source);
      return routeRequest(nest, source, "storage", name)
        .then(value => value != null ? value : next(),
              next);
    }
  }
  return next();
}
```

{{index "Map class", "Object.keys function", "Array.from function"}}

به دلیل اینکه `connections` از جنس `Map` است، <bdo>`Object.keys`</bdo> روی آن جواب نمی دهد. متد
`keys` در این شیء هم وجود دارد اما یک شمارنده را برمی گرداند نه یک آرایه. یک
شمارنده (یا مقدار شمارنده) را می توان به وسیله‌ی <bdo>`Array.from`</bdo> به آرایه تبدیل کرد.

{{index "Promise class", recursion}}

حتی با وجود استفاده از promise ها این کد نسبتا شکل خوبی ندارد.
عملیات متعدد ناهمگام با هم زنجیر شده اند به صورتی که اصلا خوانا و واضح نیست. دوباره
نیاز به یک تابع بازگشتی داریم (`next`) تا بتوانیم حلقه (looping) را بین لانه‌ها مدل
سازی کنیم.

{{index "synchronous programming", "asynchronous programming"}}

و این که کاری که این کد درواقع انجام می دهد کاملا خطی است – همیشه منتظر اتمام
عمل قبلی پیش از شروع￼ عمل بعدی می ماند. در یک مدل برنامه نویسی همگام ، ساده‌تر می
توان این کارها را پیاده سازی کرد.

{{index "async function", "await keyword"}}

خبر خوب این است که جاوااسکریپت این امکان را فراهم کرده است که کدهای شبه-همگام بنویسید.
یک تابع `async` تابعی است که به طور ضمنی یک promise را بر‌می‌گرداند و می تواند در بدنه‌اش ، به وسیله‌ی دستور `await` منتظر دیگر promiseها باشد به طوری که همگام به نظر برسد.

{{index "findInStorage function"}}

می توانیم تابع `findInStorage` را به شکل زیر بازنویسی کنیم.

```
async function findInStorage(nest, name) {
  let local = await storage(nest, name);
  if (local != null) return local;

  let sources = network(nest).filter(n => n != nest.name);
  while (sources.length > 0) {
    let source = sources[Math.floor(Math.random() *
                                    sources.length)];
    sources = sources.filter(n => n != source);
    try {
      let found = await routeRequest(nest, source, "storage",
                                     name);
      if (found != null) return found;
    } catch (_) {}
  }
  throw new Error("Not found");
}
```

{{index "async function", "return keyword", "exception handling"}}

یک تابع async را می توان با واژه‌ی `async` قبل از کلیدواژه‌ی `function` مشخص کرد.
متدها را نیز می توان با نوشتن آن قبل از نام متد تبدیل به `async` کرد . زمانی که
تابع یا متدی با این خصوصیت فراخوانی شود یک promise را تولید خواهد کرد. به محض این که
بدنه‌ی تابع چیزی را برگرداند، آن promise نتیجه‌یابی می شود. اگر
استثنایی تولید کند، promise رد می شود.

{{if interactive

```{startCode: true}
findInStorage(bigOak, "events on 2017-12-21")
  .then(console.log);
```

if}}

{{index "await keyword", ["control flow", asynchronous]}}

درون یک تابع `async،` واژه‌ی `await` را می توان در ابتدای یک عبارت قرار داد تا تابع
برای دریافت نتیجه‌ی promise منتظر بماند و بعد از آن به ادامه‌ی اجرای تابع
بپردازد.

این گونه توابع دیگر مانند توابع معمولی جاوااسکریپت از ابتدا تا انتها در یک حرکت
اجرا نمی شوند. بلکه ممکن است در هر نقطه‌ای که یک `await` دارند ایست کنند و بعدا به
ادامه مسیرشان بپردازند.

برای کدهای ناهمگام مهم، استفاده از این روش معمولا مناسب تر است از استفاده از
promise ها. حتی اگر لازم است که کاری انجام بدهید که مناسب مدل همگام نیست، مثل
اجرای چندین کار در یک زمان، به آسانی می توان `await` را با استفاده مستقیم از
promise ها ترکیب کرد.

## مولدها Generators

{{index "async function"}}

این قابلیت در توابع که می توانند متوقف شده و بعدا دوباره به مسیرشان ادامه بدهند
فقط مخصوص به توابع `async` نیست. جاوااسکریپت قابلیتی به نام توابع _((generator))_
(مولد) دارد. این توابع به طور مشابه عمل می کنند اما بدون promise ها.

زمانی که تابعی را با `function*` (یک ستاره بعد از کلیدواژه‌ی function قرار می
دهید)، تعریف می کنید، باعث می شود که آن تابع به یک مولد تبدیل شود. زمانی که یک
تابع مولد فراخوانی می شود، یک تکرار‌کننده (iterator) را برمی گرداند که￼ پیش تر در [فصل ?](object) دیده
ایم.

```
function* powers(n) {
  for (let current = n;; current *= n) {
    yield current;
  }
}

for (let power of powers(3)) {
  if (power > 50) break;
  console.log(power);
}
// → 3
// → 9
// → 27
```

{{index "next method", "yield keyword"}}

در ابتدا، وقتی که تابع `powers` را فراخوانی می کنید، تابع در ابتدای خودش ایست می
کند. هر بار که `next` را روی تکرارکننده فراخوانی می کنید، تابع تا رسیدن به یک عبارت
`yield` اجرا می شود، و دوباره متوقف شده و مقداری که به وسیله‌ی `yield` حاصل شده است
به عنوان مقدار بعدی تولیدی توسط تکرارکننده در نظر گرفته می شود. زمانی که تابع به
پایان می رسد (که در این مثال هرگز اتفاق نمی افتد) تکرارکننده نیز به پایان می رسد.

نوشتن تکرارکننده‌ها اغلب در هنگام استفاده از توابع مولد ساده تر می باشد. تکرارکننده‌ی
مربوط به کلاس `Groupe` (مربوط به تمرین [فصل ?](object#group_iterator)) را می توان با این مولد بازنویسی کرد:

{{index "Group class"}}

```
Group.prototype[Symbol.iterator] = function*() {
  for (let i = 0; i < this.members.length; i++) {
    yield this.members[i];
  }
};
```

```{hidden: true, includeCode: true}
class Group {
  constructor() { this.members = []; }
  add(m) { this.members.add(m); }
}
```

{{index [state, in iterator]}}

دیگر نیازی نیست که یک شیء را ایجاد کرده تا وضعیت تکرار را نگه داری کنیم – مولدها
این کار را به صورت خودکار با ذخیره‌ی وضعیت محلی‌شان با هر بار خواندن yield انجام می دهند.

عبارت‌های `yield` فقط می توانند مستقیما درون خود تابع مولد استفاده شوند نه درون
تابعی که درون مولد تعریف می کنید. وضعیتی که یک مولد در هنگام اجرای yield ذخیره
می کند ، فقط شامل محیط محلی آن و موقعیتی که در آنجا yield انجام شده می شود.

{{index "await keyword"}}

یک تابع `async` یک نوع خاص از یک مولد است. در هنگام فراخوانی یک promise تولید می
کند که در هنگام پایان تابع به نتیجه می رسد و زمانی که یک استثنا تولید می کنند
reject می شوند. هر وقت که این تابع یک promise را yield می کند (به عبارتی با
`await` منتظر یک promise می ماند)، نتیجه‌ی آن promise (مقدار یا استثنای تولید
شده) نتیجه‌ی عبارت `await` خواهد بود.

## The event loop

{{index "asynchronous programming", scheduling, "event loop", timeline}}

Asynchronous programs are executed piece by piece. Each piece may
start some actions and schedule code to be executed when the action
finishes or fails. In between these pieces, the program sits idle,
waiting for the next action.

{{index "setTimeout function"}}

So callbacks are not directly called by the code that scheduled them.
If I call `setTimeout` from within a function, that function will have
returned by the time the callback function is called. And when the
callback returns, control does not go back to the function that
scheduled it.

{{index "Promise class", "catch keyword", "exception handling"}}

Asynchronous behavior happens on its own empty function ((call
stack)). This is one of the reasons that, without promises, managing
exceptions across asynchronous code is hard. Since each callback
starts with a mostly empty stack, your `catch` handlers won't be on
the stack when they throw an exception.

```
try {
  setTimeout(() => {
    throw new Error("Woosh");
  }, 20);
} catch (_) {
  // This will not run
  console.log("Caught!");
}
```

{{index thread, queue}}

No matter how closely together events—such as timeouts or incoming
requests—happen, a JavaScript environment will run only one program at
a time. You can think of this as it running a big loop _around_ your
program, called the _event loop_. When there's nothing to be done,
that loop is stopped. But as events come in, they are added to a queue,
and their code is executed one after the other. Because no two things
run at the same time, slow-running code might delay the handling of
other events.

This example sets a timeout but then dallies until after the
timeout's intended point of time, causing the timeout to be late.

```
let start = Date.now();
setTimeout(() => {
  console.log("Timeout ran at", Date.now() - start);
}, 20);
while (Date.now() < start + 50) {}
console.log("Wasted time until", Date.now() - start);
// → Wasted time until 50
// → Timeout ran at 55
```

{{index "resolving (a promise)", "rejecting (a promise)", "Promise class"}}

Promises always resolve or reject as a new event. Even if a promise is
already resolved, waiting for it will cause your callback to run after
the current script finishes, rather than right away.

```
Promise.resolve("Done").then(console.log);
console.log("Me first!");
// → Me first!
// → Done
```

In later chapters we'll see various other types of events that run on
the event loop.

## Asynchronous bugs

{{index "asynchronous programming", [state, transitions]}}

When your program runs synchronously, in a single go, there are no
state changes happening except those that the program itself
makes. For asynchronous programs this is different—they may have
_gaps_ in their execution during which other code can run.

Let's look at an example. One of the hobbies of our crows is to count
the number of chicks that hatch throughout the village every year.
Nests store this count in their storage bulbs. The following code tries to
enumerate the counts from all the nests for a given year:

{{index "anyStorage function", "chicks function"}}

```{includeCode: true}
function anyStorage(nest, source, name) {
  if (source == nest.name) return storage(nest, name);
  else return routeRequest(nest, source, "storage", name);
}

async function chicks(nest, year) {
  let list = "";
  await Promise.all(network(nest).map(async name => {
    list += `${name}: ${
      await anyStorage(nest, name, `chicks in ${year}`)
    }\n`;
  }));
  return list;
}
```

{{index "async function"}}

The `async name =>` part shows that ((arrow function))s can also be
made `async` by putting the word `async` in front of them.

{{index "Promise.all function"}}

The code doesn't immediately look suspicious...it maps the `async`
arrow function over the set of nests, creating an array of promises,
and then uses `Promise.all` to wait for all of these before returning
the list they build up.

But it is seriously broken. It'll always return only a single line of
output, listing the nest that was slowest to respond.

{{if interactive

```
chicks(bigOak, 2017).then(console.log);
```

if}}

Can you work out why?

{{index "+= operator"}}

The problem lies in the `+=` operator, which takes the _current_ value
of `list` at the time where the statement starts executing and then,
when the `await` finishes, sets the `list` binding to be that value
plus the added string.

{{index "await keyword"}}

But between the time where the statement starts executing and the time
where it finishes there's an asynchronous gap. The `map` expression
runs before anything has been added to the list, so each of the `+=`
operators starts from an empty string and ends up, when its storage
retrieval finishes, setting `list` to a single-line list—the result of
adding its line to the empty string.

{{index "side effect"}}

This could have easily been avoided by returning the lines from the
mapped promises and calling `join` on the result of `Promise.all`,
instead of building up the list by changing a binding. As usual,
computing new values is less error-prone than changing existing
values.

{{index "chicks function"}}

```
async function chicks(nest, year) {
  let lines = network(nest).map(async name => {
    return name + ": " +
      await anyStorage(nest, name, `chicks in ${year}`);
  });
  return (await Promise.all(lines)).join("\n");
}
```

Mistakes like this are easy to make, especially when using `await`,
and you should be aware of where the gaps in your code occur. An
advantage of JavaScript's _explicit_ asynchronicity (whether through
callbacks, promises, or `await`) is that spotting these gaps is
relatively easy.

## Summary

Asynchronous programming makes it possible to express waiting for
long-running actions without freezing the program during these
actions. JavaScript environments typically implement this style of
programming using callbacks, functions that are called when the
actions complete. An event loop schedules such callbacks to be called
when appropriate, one after the other, so that their execution does
not overlap.

Programming asynchronously is made easier by promises, objects that
represent actions that might complete in the future, and `async`
functions, which allow you to write an asynchronous program as if it
were synchronous.

## Exercises

### Tracking the scalpel

{{index "scalpel (exercise)"}}

The village crows own an old scalpel that they occasionally use on
special missions—say, to cut through screen doors or packaging. To be
able to quickly track it down, every time the scalpel is moved to
another nest, an entry is added to the storage of both the nest that
had it and the nest that took it, under the name `"scalpel"`, with its
new location as the value.

This means that finding the scalpel is a matter of following the
breadcrumb trail of storage entries, until you find a nest where that
points at the nest itself.

{{index "anyStorage function", "async function"}}

Write an `async` function `locateScalpel` that does this, starting at
the nest on which it runs. You can use the `anyStorage` function
defined earlier to access storage in arbitrary nests. The scalpel has
been going around long enough that you may assume that every nest has
a `"scalpel"` entry in its data storage.

Next, write the same function again without using `async` and `await`.

{{index "exception handling"}}

Do request failures properly show up as rejections of the returned
promise in both versions? How?

{{if interactive

```{test: no}
async function locateScalpel(nest) {
  // Your code here.
}

function locateScalpel2(nest) {
  // Your code here.
}

locateScalpel(bigOak).then(console.log);
// → Butcher Shop
```

if}}

{{hint

{{index "scalpel (exercise)"}}

This can be done with a single loop that searches through the nests,
moving forward to the next when it finds a value that doesn't match
the current nest's name and returning the name when it finds a
matching value. In the `async` function, a regular `for` or `while`
loop can be used.

{{index recursion}}

To do the same in a plain function, you will have to build your loop
using a recursive function. The easiest way to do this is to have that
function return a promise by calling `then` on the promise that
retrieves the storage value. Depending on whether that value matches
the name of the current nest, the handler returns that value or a
further promise created by calling the loop function again.

Don't forget to start the loop by calling the recursive function once
from the main function.

{{index "exception handling"}}

In the `async` function, rejected promises are converted to exceptions
by `await`. When an `async` function throws an exception, its promise
is rejected. So that works.

If you implemented the non-`async` function as outlined earlier, the way
`then` works also automatically causes a failure to end up in the
returned promise. If a request fails, the handler passed to `then`
isn't called, and the promise it returns is rejected with the same
reason.

hint}}

### Building Promise.all

{{index "Promise class", "Promise.all function", "building Promise.all (exercise)"}}

Given an array of ((promise))s, `Promise.all` returns a promise that
waits for all of the promises in the array to finish. It then
succeeds, yielding an array of result values. If a promise
in the array fails, the promise returned by `all` fails too, with the
failure reason from the failing promise.

Implement something like this yourself as a regular function
called `Promise_all`.

Remember that after a promise has succeeded or failed, it can't
succeed or fail again, and further calls to the functions that resolve
it are ignored. This can simplify the way you handle failure of your
promise.

{{if interactive

```{test: no}
function Promise_all(promises) {
  return new Promise((resolve, reject) => {
    // Your code here.
  });
}

// Test code.
Promise_all([]).then(array => {
  console.log("This should be []:", array);
});
function soon(val) {
  return new Promise(resolve => {
    setTimeout(() => resolve(val), Math.random() * 500);
  });
}
Promise_all([soon(1), soon(2), soon(3)]).then(array => {
  console.log("This should be [1, 2, 3]:", array);
});
Promise_all([soon(1), Promise.reject("X"), soon(3)])
  .then(array => {
    console.log("We should not get here");
  })
  .catch(error => {
    if (error != "X") {
      console.log("Unexpected failure:", error);
    }
  });
```

if}}

{{hint

{{index "Promise.all function", "Promise class", "then method", "building Promise.all (exercise)"}}

The function passed to the `Promise` constructor will have to call
`then` on each of the promises in the given array. When one of them
succeeds, two things need to happen. The resulting value needs to be
stored in the correct position of a result array, and we must check
whether this was the last pending ((promise)) and finish our own
promise if it was.

{{index "counter variable"}}

The latter can be done with a counter that is initialized to the
length of the input array and from which we subtract 1 every time a
promise succeeds. When it reaches 0, we are done. Make sure you take
into account the situation where the input array is empty (and thus no
promise will ever resolve).

Handling failure requires some thought but turns out to be extremely
simple. Just pass the `reject` function of the wrapping promise to
each of the promises in the array as a `catch` handler or as a second
argument to `then` so that a failure in one of them triggers the
rejection of the whole wrapper promise.

hint}}
