# Functions

{{quote {author: "Donald Knuth", chapter: true}

People think that computer science is the art of geniuses but the
actual reality is the opposite, just many people doing things that
build on each other, like a wall of mini stones.

quote}}

{{index "Knuth, Donald"}}

{{figure {url: "img/chapter_picture_3.jpg", alt: "Picture of fern leaves with a fractal shape", chapter: framed}}}

{{index function, [code, "structure of"]}}

توابع از پایه‌های اصلی برنامه نویسی به زبان جاوااسکریپت هستند. مفهموم قراردادن قطعه برنامه‌ای درون یک مقدار کاربردهای زیادی دارد. از آن می توان برای ساختاردهی به برنامه‌های بزرگتر استفاده کرد، از تکرار پرهیز کرد، به زیربرنامه ها نام اختصاص داد و آن ها را به شکلی مستقل مجزا کرد.

واضح ترین کاربرد‌ توابع، استفاده از آن‌ها برای تعریف ((واژه‌ی)) جدید است. خلق واژه‌ای جدید در یک نثر معمولی معمولا کار جالبی نیست اما در برنامه نویسی این کار اجتناب ناپذیر است.

{{index abstraction, vocabulary}}

معمولا انگلیسی زبانان بزرگسال در دامنه واژگانشان حدود 20,000 کلمه دارند. زبان‌های برنامه نویسی کمی هستند که 20,000 دستور از پیش تعریف شده دارند.  و این دستورات یا واژگانی که در دسترس هستند به صورت دقیقی تعریف می شوند که در نتیجه انعطاف کمتری نسبت به زبان‌های بشری دارند. بنابراین، معمولا بایستی مفاهیم جدید را خودمان تعریف کنیم تا خیلی درگیر تکرار نشویم.


## تعریف یک تابع

{{index "square example", [function, definition], [binding, definition]}}

تعریف یک تابع همان تعریف عادی یک متغیر است با این تفاوت که مقداری که به متغیر اختصاص داده می شود، از جنس تابع است. به عنوان مثال، کد پیش رو متغیر `square` را تعرف می کند که به تابعی ارجاع می دهد که مربع عدد داده شده را تولید می کند:

```
const square = function(x) {
  return x * x;
};

console.log(square(12));
// → 144
```

{{indexsee "curly braces", braces}}
{{index [braces, "function body"], block, [syntax, function], "function keyword", [function, body], [function, "as value"], [parentheses, arguments]}}

یک تابع را می توان به وسیله‌ی یک عبارت که با کلمه‌ی کلیدی `function` شروع می شود ایجاد کرد.توابع دارای  مجموعه‌ای از _((پارامترها))_ (در مثال بالا فقط `x`) و یک _بدنه_ که خود در بردارنده دستوراتی است که در صورت فراخوانی تابع اجرا می شوند، می باشد. بدنه‌ی تابع می بایست همیشه درون کروشه‌ها قرار گیرد حتی زمانی که فقط حاوی یک ((دستور)) است ( مانند مثال قبل ).

{{index "power example"}}

یک تابع می تواند چندین پارامتر داشته باشد یا هیچ پارامتری نداشته باشد. در مثال پیش رو، تابع `makeNoise` هیچ پارامتری ندارد در حالیکه  تابع `power` دو پارامتر دارد:

```
const makeNoise = function() {
  console.log("Pling!");
};

makeNoise();
// → Pling!

const power = function(base, exponent) {
  let result = 1;
  for (let count = 0; count < exponent; count++) {
    result *= base;
  }
  return result;
};

console.log(power(2, 10));
// → 1024
```

{{index "return value", "return keyword", undefined}}

بعضی توابع مقداری را برمی گردانند،‌ مانند تابع `power` و `square`، و بعضی توابع مانند `makeNoise` فقط اثر جانبی تولید می کنند و مقداری را باز نمی گردانند. دستوری به نام `return` مسئول بازگرداندن مقداری از تابع است. زمانی که برنامه به این دستور می رسد، به سرعت از تابع فعلی خارج شده و مقداری که “برگردانده شده” را به قسمتی از برنامه که تابع در آنجا فراخوانی شده، ارسال می کند. استفاده از دستور `return` بدون عبارتی بعد از آن ، باعث می شود که تابع مقدار `undefined` را برگرداند. توابعی که اصلا دستور `return` را ندارند مانند `makeNoise` نیز مقدار `undefined` را برمی گردانند.

{{index parameter, [function, application], [binding, "from parameter"]}}

پارامترها در توابع درست شبیه متغیرهای عادی رفتار می کنند اما مقدار اولیه آن ها توسط _فراخواننده_ تابع مقداردهی می شود نه کدی که در بدنه تابع نوشته می شود.

## متغیرها و قلمرو‌ی آن

{{indexsee "top-level scope", "global scope"}}
{{index "var keyword", "global scope", [binding, global], [binding, "scope of"]}}

هر متغیری دارای یک _((قلمرو))_ دسترسی است که عبارت است از بخشی از برنامه که در آن متغیر قابل دسترسی و مشاهده است. برای متغیرهایی که بیرون از یک تابع یا یک بلاک تعریف شده اند، این حوزه شامل کل برنامه می شود – می توانید به این متغیرها در هرجای برنامه دسترسی داشته باشید. به این متغیرها متغیرهای _سراسری_ گفته می شود.

{{index "local scope", [binding, local]}}

اما متغیرهایی که برای پارامترهای توابع ایجاد می شوند یا آن هایی که درون یک تابع تعریف می شوند، فقط در درون همان تابع قابل ارجاع می باشند، به همین علت به آن ها متغیرهای _محلی_ گفته می شود. هر دفعه که تابعی فراخوانی می شود، یک نمونه از این متغیرها ایجاد می شود. این کار باعث می شود که توابع به نوعی نسبت به هم مجزا (‌ایزوله) شوند- هر فراخوانی تابع در فضای اختصاصی خودش عمل می کند (محیط محلی خودش) و معمولا می توان این نحوه‌ی عملکرد را از برنامه دریافت بدون اینکه بخواهیم از جزئیاتی که در محیط اجرایی برنامه باخبر شویم.

{{index "let keyword", "const keyword", "var keyword"}}

متغیرهایی که با `let`  یا `const` تعریف می شوند در واقع نسبت به _((بلاکی))_ که درون آن تعریف شده اند محلی هستند، بنابراین اگر یکی از آن ها درون یک حلقه تعریف کنید، کدی که قبل و بعد از حلقه قرار گرفته نمی تواند آن را “ببیند”. در نسخه‌های قبل از 2015 جاوااسکریپت(؟)، فقط توابع بودند که می توانستند حوزه‌ی جدید ایجاد کنند، بنابراین متغیرهای قدیمی که با `var` تعریف می شدند در تابعی که که درآن تعریف شده بودند، دیده می شدند یا اگر بیرون تابع بودن، در کل برنامه در دسترس بوند.

```
let x = 10;
if (true) {
  let y = 20;
  var z = 30;
  console.log(x + y + z);
  // → 60
}
// y is not visible here
console.log(x + z);
// → 40
```

{{index [binding, visibility]}}

هر ((قلمرو)) می تواند حوزه‌ی پیرامونش را ببیند، مثلا در مثال بالا، متغیر `x` در درون بلاک قابل مشاهده است. یک استثناء اینجا زمانی رخ می دهد که چندین متغیر با یک نام وجود داشته باشد که در این صورت، کد برنامه می تواند درونی‌ترین مورد را ببیند. به عنوان مثلا، در تابع `halve` مثال پایین، زمانی که کد درون تابع به متغیر `n` اشاره می کند، متغیر `n` _خود_ تابع استفاده می شود نه متغیر سراسری `n`.

```
const halve = function(n) {
  return n / 2;
};

let n = 10;
console.log(halve(100));
// → 50
console.log(n);
// → 10
```

{{id scoping}}

### قلمروی تو در تو

{{index [nesting, "of functions"], [nesting, "of scope"], scope, "inner function", "lexical scoping"}}

جاوااسکریپت تنها بین متغیرهای _سراسری_ و _محلی_ تفاوت قائل نمی شود. می توان توابع و بلاک‌ها را نیز به شکل تودرتو ایجاد کرد که باعث ایجاد درجه‌های مختلفی از محلی بودن میگردد.

{{index "landscape example"}}

به عنوان مثال، این تابع – که مواد لازم برای تهیه حمص (نوعی غذا) را برمی گرداند – تابعی دیگر در درون خود دارد:

```
const hummus = function(factor) {
  const ingredient = function(amount, unit, name) {
    let ingredientAmount = amount * factor;
    if (ingredientAmount > 1) {
      unit += "s";
    }
    console.log(`${ingredientAmount} ${unit} ${name}`);
  };
  ingredient(1, "can", "chickpeas");
  ingredient(0.25, "cup", "tahini");
  ingredient(0.25, "cup", "lemon juice");
  ingredient(1, "clove", "garlic");
  ingredient(2, "tablespoon", "olive oil");
  ingredient(0.5, "teaspoon", "cumin");
};
```

{{index [function, scope], scope}}

کدی که در تابع `ingredient` قرار دارد می تواند متغیر `factor` را از تابع بیرونی ببیند. اما متغیرهای محلیش مانند `unit` یا `ingredientAmount` توسط تابع بیرونی قابل مشاهده نیستند.

مجموعه‌ای از متغیرها که درون یک بلاک قابل رویت هستند بستگی به مکان بلاک در متن برنامه دارد.  هر قلمروی محلی همچنین می تواند قلمرو‌های محلی ای که آن را در بر گرفته اند را ببیند و همه قلمروها می تواند قلمرو سراسری را ببینند. این روش رویت پذیری متغیر را _((حوزه‌بندی لغوی))_ می نامند.

## استفاده از توابع به عنوان مقدار

{{index [function, "as value"], [binding, definition]}}

متغیرهایی که توابع را نگه‌داری می کنند معمولا به شکلی ساده نقش یک نام را برای قطعه‌ای از برنامه بازی می کنند. این گونه متغیرها یک بار تعریف شده و دیگر تغییر نمی یابند. این امر ممکن است باعث بروز اشتباهاتی بین خود تابع و نام آن بشود.

{{index [binding, assignment]}}

اما این دو متفاوتند. یک مقدار تابع می تواند همه‌ی چیزهایی که دیگر مقدارها، انجام می دهند را انجام دهد – می توانید از آن ها در ((عبارت‌ها)) استفاده کنید نه اینکه فقط آن ها را فراخوانی کنید. می توان مقدار تابع را در متغیر جدیدی ذخیره کرد، به عنوان آرگومان به یک تابع فرستاد و از این قبیل. به طور مشابه متغیری که یک تابع را نگه داری می کند هنوز فقط یک متغیر عادی است و می توان مقدار جدیدی به آن اختصاص داد البته اگر به عنوان ثابت تعریف نشده باشد. مثلا:

```{test: no}
let launchMissiles = function() {
  missileSystem.launch("now");
};
if (safeMode) {
  launchMissiles = function() {/* do nothing */};
}
```

{{index [function, "higher-order"]}}

در [فصل ?](higher_order)، در مورد کارهای جالبی که می توان به وسیله ارسال توابع به عنوان مقدار به دیگر توابع انجام داد بحث خواهیم کرد.

## استفاده از روش اعلان تابع

{{index [syntax, function], "function keyword", "square example", [function, definition], [function, declaration]}}

روش نسبتا کوتاه‌تری برای ایجاد یک تابع  وجود دارد. زمانی که از کلمه کلیدی `function` در ابتدای یک دستور استفاده می کنیم، این تعریف به شکل دیگری صورت می گیرد.

```{test: wrap}
function square(x) {
  return x * x;
}
```

{{index future, "execution order"}}

این روش، تعریف تابع با _اعلان_ آن است. این دستور متغیری به نام `square` را تعریف کرده و آن را به تابع داده شده مرتبط می کند. تعریف تابع به این روش اندکی ساده تر به نظر می رسد و در این روش نیازی نیست بعد از تعریف تابع از نقطه ویرگول استفاده کنید.

در اینجا یک نکته‌ی ریز در این شکل از تعریف تابع وجود دارد.

```
console.log("The future says:", future());

function future() {
  return "You'll never have flying cars";
}
```

کد بالا به درستی کار می کند اگرچه تعریف تابع پایین تر از خطی که فراخوانی می شود اتفاق افتاده است. دلیل این اتفاق این است که اعلان‌های توابع در جاوااسکریپت به عنوان بخشی از جریان کنترل بالا به پایین عادی برنامه محسوب نمی شوند. به طور مفهومی آن ها به بالای حوزه‌ی خودشان منتقل می شوند و می توان از آن‌ها در همه‌ی کدهای موجود در آن حوزه استفاده کرد. این ویژگی گاهی اوقات کاربردی است چرا که این آزادی را به ما می دهد تا به شکلی کدها را مرتب کنیم که بهتر سازماندهی بشوند بدون اینکه نگران این باشیم که توابع ما حتما قبل از محل فراخوانی‌شان تعریف شده باشند.

## Arrow functions

{{index function, "arrow function"}}

روش سومی هم برای تعریف توابع وجود دارد، که با روش‌های قبلی خیلی متفاوت‌ به نظر می رسد. به جای استفاده از کلیدواژه‌ی `function` از یک پیکان <bdo>(`=>`)</bdo> که از علامت مساوی و بزرگتر استفاده می شود. ( نباید با عملگر بزرگتر-یا-مساوی-از اشتباه گرفته شود، که به شکل <bdo>`>=`</bdo> نوشته می شود)

```{test: wrap}
const power = (base, exponent) => {
  let result = 1;
  for (let count = 0; count < exponent; count++) {
    result *= base;
  }
  return result;
};
```

{{index [function, body]}}

کاراکتر پیکان درست بعد از لیستی از پارامترها می آید که _بعد_ از آن بدنه‌ی تابع خواهد آمد. می توان به نوعی این طور تفسیرش کرد که ” این ورودی ((پارامتر))ها) این نتیجه ( بدنه‌ی تابع‌ ) را تولید خواهد کرد”.

{{index [braces, "function body"], "square example", [parentheses, arguments]}}

زمانی که تنها یک پارامتر وجود دارد، می توانید از پرانتزها صرف نظر کنید. اگر بدنه تابع فقط شامل یک عبارت است، نسبت به یک بلاک که توسط کروشه‌ها محصور شده، آن عبارت توسط تابع برگردانده می شود. بنابراین  دو روش تعریف تابع `square` در زیر، کار مشابهی را انجام می دهند:

```
const square1 = (x) => { return x * x; };
const square2 = x => x * x;
```

{{index [parentheses, arguments]}}

زمانی که یک arrow function فاقد پارامتر است، لیست پارامترهایش به صورت یک جفت پرانتز خالی نوشته می شود.

```
const horn = () => {
  console.log("Toot");
};
```

{{index verbosity}}

نمی توان دلیل خیلی خوبی برای اینکه در زبان جاوااسکریپت نیاز به هر دو نوع تعریف تابع (روش پیکانی و معمول) وجود دارد پیدا کرد. از موارد جزئی که بگذریم ( که در [فصل ?](object) به آن ها می پردازیم)، هر دوی آن ها کار یکسانی را انجام می دهند. روش پیکانی در سال 2015 به زبان اضافه شد بیشتر به این خاطر که بتوان توابع را به شکل کوتاه‌تر و خلاصه نوشت و از درازنویسی پرهیز کرد. در [فصل ?](higher_order) از آن‌ها زیاد استفاده خواهیم کرد.

{{id stack}}

## پشته‌ی فراخوانی توابع

{{indexsee stack, "call stack"}}
{{index "call stack", [function, application]}}

روشی که کنترل برنامه در توابع جریان می یابد، نسبتا کمی پیچیده است. بجاست تا نگاهی دقیق تر به نحوه‌ی جریان کنترل در توابع بیاندازیم. در اینجا برنامه‌ی ساده ای داریم که چند فراخوانی تابع دارد:

```
function greet(who) {
  console.log("Hello " + who);
}
greet("Harry");
console.log("Bye");
```

{{index ["control flow", functions], "execution order", "console.log"}}

اجرای این برنامه به طور کلی به این شکل خواهد بود: فراخوانی تابع `greet` باعث می شود که کنترل برنامه به شروع بدنه‌ی آن تابع (خط 2) بپرد. تابع `console.log` (که تابعی از پیش ساخته شده در مرورگر است) را فراخوانی می کند، که کنترل را در دست گرفته، کارش را انجام می دهد و دوباره کنترل را به خط 2 بازمی گرداند. سپس به انتهای تابع `greet` می رسد بنابراین به جایی که در ابتدا فراخوانی شده بود باز می گردد، خط 4. خط بعدی دوباره `console.log` را فراخوانی می کند. بعد از آن، برنامه به پایان خود می رسد.

می توانیم این جریان کنترل را به صورت شماتیک به این صورت نشان دهیم:

```{lang: null}
not in function
   in greet
        in console.log
   in greet
not in function
   in console.log
not in function
```

{{index "return keyword", [memory, call stack]}}

به دلیل اینکه تابع پس از اجرا می بایست به نقطه‌ای که از آن‌جا فراخوانی شده است بازگردد، کامپیوتر باید مکانی از برنامه که تابع از آنجا فراخوانی شده است را به خاطر بیاورد. در یک مورد، `console.log` پس از اجرا باید به تابع `greet` برگردد و در مورد بعدی به انتهای برنامه بر می گردد.

جایی از کامپیوتر که این محل یا زمینه (context) ذخیره می شود _((پشته‌ی فراخوانی))_ می باشد. هر بار که تابعی فراخوانی می شود، محل فعلی فراخوانی در بالای این “پشته” قرار می گیرد. زمانی که اجرای تابع تمام می شود، عنصر بالای پشته را از پشته حذف می کند و از آن محل برای ادامه اجرای برنامه استفاده می کند.

{{index "infinite loop", "stack overflow", recursion}}

ذخیره‌ی این پشته نیاز به فضایی در حافظه‌ی کامپیوتر دارد. در صورت رشد بیش از اندازه پشته، کامپیوتر با مشکل روبرو شده و پیغام “out of stack space” یا “too much recursion” را تولید می کند. کدی که در ادامه می آید این موضوع را بیشتر باز می کند. در این مثال کامپیوتر با مساله‌ی بسیار مشکلی روبرو می شود که باعث می شود به طور بی نهایت بین دو تابع گیر بیفتد. اگر محدودیت حافظه‌ برای پشته نبود، احتمالا اجرای این برنامه بی نهایت می شد. اما در واقع، ما با کمبود فضا روبرو می شویم، یا اینکه پشته از کار خواهد افتاد.

```{test: no}
function chicken() {
  return egg();
}
function egg() {
  return chicken();
}
console.log(chicken() + " came first.");
// → ??
```

## آرگومان‌های اختیاری

{{index argument, [function, application]}}

کد مثال زیر، معتبر است و بدون هیچ مشکلی کار می کند:

```
function square(x) { return x * x; }
console.log(square(4, true, "hedgehog"));
// → 16
```

تابع `square` را که فقط یک پارامتر دارد را تعریف کردیم. اما زمانی که به شکل بالا با سه پارامتر  آن را فراخوانی می کنیم، با خطایی روبرو نمی شویم. این تابع به جز آرگومان اول از دیگر آرگومان‌ها صرف نظر می کند و مربع عدد اول را حساب می کند.

{{index undefined}}

جاوااسکریپت نسبت به تعداد آرگومان‌های دریافتی، بسیار روشن فکرانه عمل می کند. اگر آرگومان‌های بیشتری نسبت به آنچه از قبل تعریف شده است ارسال نمایید، به سادگی از آن ها چشم پوشی می کند. اگر آرگومان کمتری ارسال کنید، به آرگومان‌هایی که مقداردهی نشده اند مقدار `undefined` را اختصاص می دهد.

جنبه‌ی منفی این کار این است که ممکن است که شما ناخواسته و تصادفی تعداد اشتباهی آرگومان را به تابع ارسال کنید و اصلا متوجه آن هم نشوید.

و جنبه مثبت  این است که می توان با استفاده از آن به یک تابع اجازه داد که آرگومان‌های متعدد و متفاوتی فراخوانی شود. به عنوان مثال، تابع `minus`  که در ادامه می آید سعی می کند که عملگر `-` را با عمل کردن روی یک یا دو آرگومان شبیه سازی کند:

```
function minus(a, b) {
  if (b === undefined) return -a;
  else return a - b;
}

console.log(minus(10));
// → -10
console.log(minus(10, 5));
// → 5
```

{{id power}}
{{index "optional argument", "default value", parameter, ["= operator", "for default value"]}}

اگر بعد از نوشتن پارامتر علامت `=` قرار داده و عبارتی را بنویسید، مقدار آن عبارت در صورتی که آرگومان ارسال نشود، جایگزین آن می شود.

{{index "power example"}}

به عنوان مثال، این نسخه از تابع `power` آرگومان دومش را اختیاری تعریف کرده است. اگر آرگومان دوم را ارسال نکنید یا اینکه مقدار `undefined` را بفرستید، مقدار پیش‌فرض 2 در نظر گرفته می شود و تابع شبیه تابع `square` عمل می کند.


```{test: wrap}
function power(base, exponent = 2) {
  let result = 1;
  for (let count = 0; count < exponent; count++) {
    result *= base;
  }
  return result;
}

console.log(power(4));
// → 16
console.log(power(2, 6));
// → 64
```

{{index "console.log"}}

در [فصل بعد](data#rest_parameters)، با راهی آشنا خواهیم شد که در بدنه تابع می توان با آن به لیست دقیق آرگومان‌های ارسالی دست پیدا کرد. با این ویژگی می توان در یک تابع هر تعداد آرگومان قبول کرد. مثلا تابع `console.log` از این ویژگی استفاده می کند- همه‌ی مقادیری که به آن داده می شود به خروجی ارسال می کند.

```
console.log("C", "O", 2);
// → C O 2
```

## بستار (closure)

{{index "call stack", "local binding", [function, "as value"], scope}}

امکان استفاده از توابع به شکل مقدار، وقتی با این واقعیت ترکیب می شود که متغیرهای محلی با هر بار فراخوانی تابع از نوع ایجاد می شوند، سوال جالبی را به ذهن می آورد. چه اتفاقی برای متغیرهای محلی می افتد زمانی که تابعی که با فراخوانیش آن ها را ایجاد کرده دیگر فعال نیست؟

کدی که در ادامه می آید مثالی از این مفهوم را نمایش می دهد. تابعی به نام `wrapValue` را تعریف کرده که درون آن متغیری محلی ایجاد شده است. سپس تابعی را بازمیگرداند که به این متغیر محلی دسترسی داشته و آن را برمی گرداند.

```
function wrapValue(n) {
  let local = n;
  return () => local;
}

let wrap1 = wrapValue(1);
let wrap2 = wrapValue(2);
console.log(wrap1());
// → 1
console.log(wrap2());
// → 2
```

این کار مجاز و معتبر است و به خوبی کار می کند درست همانطور که انتظارش را دارید- هر دوی نمونه‌های متغیر مورد نظر هنوز در دسترس هستند. در واقع، نمونه‌های متعددی از متغیر را می توان در یک زمان زنده نگه داشت که خود مثال خوبی از این مفهوم است که متغیرهای محلی واقعا با هر با فراخوانی از نو ایجاد می شوند و فراخوانی های مختلف نمی توانند روی متغیرهای محلی یکدیگر اثری داشته باشند.

این ویژگی - امکان رجوع به یک نمونه مشخص از متغیرهای محلی محصور در یک تابع – _((بستار))_ یا کلوژر نامیده می شود. تابعی که به متغیرهایی که در حوزه‌ی محلی پیرامونش قرار دارند ارجاع می دهد را _یک_ بستار می نامند. این رفتار نه تنها شما را از نگرانی برای عمر متغیرها آزاد می کند بلکه همچنین این امکان استفاده‌های خلاقانه از مقدارهای تابع را فراهم می کند.

{{index "multiplier function"}}

با کمی تغییر می توانیم مثال قبل را به روشی برای ایجاد توابعی که عمل ضرب را با یک مقدار دلخواه انجام می دهند استفاده کنیم.

```
function multiplier(factor) {
  return number => number * factor;
}

let twice = multiplier(2);
console.log(twice(5));
// → 10
```

{{index [binding, "from parameter"]}}

به طور صریح نیازی به متغیر `local` از مثال `wrapValue` وجود ندارد به این علت که پارامتر خود یک متغیر محلی محسوب می شود.

{{index [function, "model of"]}}

 درک و فکر کردن به برنامه‌هایی شبیه مثال بالا نیاز به مقدار تمرین دارد. یک مدل ذهنی خوب این است که فرض کنید که مقدارهای تابع، کد،‌بدنه و محیطی که در آن ایجاد شده اند را نگه داری می کنند. زمانی که فراخوانی می شوند، بدنه تابع محیطی که در آن ایجاد شده را می بیند نه محیطی که در آن فراخوانی شده است.

در مثال، `multiplier` فراخوانی شده و محیطی را ایجاد کرده است که در آن پارامتر `factor` به 2 اختصاص داده شده است. مقدار تابعی که برمی گرداند، که خود در `twice` ذخیره شده است، محیط را به خاطر می آورد. بنابراین در هنگام فراخوانی، آرگومانش را در 2 ضرب می کند.

## بازگشتی

{{index "power example", "stack overflow", recursion, [function, application]}}

فراخوانی یک تابع توسط خودش امری کاملا قابل قبول است البته تا زمانی که به نحوی انجام شود که باعث سرریز پشته نشود. تابعی که خودش را فراخوانی می کند را تابع _بازگشتی_ می نامند. بازگشت این امکان را فراهم می سازد که بعضی توابع را به سبک دیگری بتوان نوشت. به عنوان مثال، به سبک دیگری که می توان تابع `power` را پیاده سازی کرد توجه نمایید:

```{test: wrap}
function power(base, exponent) {
  if (exponent == 0) {
    return 1;
  } else {
    return base * power(base, exponent - 1);
  }
}

console.log(power(2, 3));
// → 8
```

{{index loop, readability, mathematics}}

این روش  نسبتا شبیه راهی است که ریاضی‌دانان به توان رساندن اعداد را تعریف می کنند و احتمالا مفهوم  این تابع را نسب به نوع استفاده از حلقه‌ها، به شکل روشن تری (خواناتر) توصیف می کند. تابع خودش را چندین مرتبه با توان های کوچکتر فراخوانی می کند تا به حاصل مجموعه ضرب‌ها برسد.

{{index [function, application], efficiency}}

اما این روش پیاده‌سازی یک مشکل مهم دارد: در پیاده‌سازی‌های رایج جاوااسکریپت، تقریبا سه برابر کندتر از روش استفاده از حلقه عمل می کند. پیمایش یک حلقه‌ی ساده بسیار هزینه‌ی کمتری نسبت به فراخوانی چندباره‌ی یک تابع دارد.

{{index optimization}}

معمای انتخاب بین خوانایی کد و سرعت اجرای بهتر، مساله‌ی جالبی است. می توان آن را به عنوان نوعی از مسائل مربوط به انسان پسند بودن و ماشین پسند بودن در نظر گرفت. تقریبا همه‌ی برنامه ها را می توان سریع‌تر ساخت اما با بزرگتر کردن و پیچیده کردن آن. برنامه‌نویس بایستی تصمیمی بر اساس تعادل این دو بگیرد.

در مورد تابع `power` که پیش تر آمد، روش استفاده از حلقه همچنان نسبتا قابل خواندن و فهمیدن است. زیاد توجیه ندارد که آن را با روش بازگشتی جایگزین کنیم. اگرچه گاهی یک برنامه با گونه‌ای از مفاهیم پیچیده روبرو است که صرف نظر کردن از مقداری سرعت یا کارایی در برابر سرراستی بیشتر گزینه‌ای جذاب به نظر می رسد.

{{index profiling}}

نگرانی در باره‌ی سرعت/کارایی برنامه می تواند شما را از مساله اصلی دور کند. شما هنگام برنامه نویسی مشغول حل مساله‌ای مشکل هستید و وقتی فاکتور پیچیده‌ی دیگری به طور همزمان شما را نگران کند، باعث می شود که نتوانید جلو بروید.

{{index "premature optimization"}}

بنابراین، همیشه در ابتدا کدی را بنویسید که به طور صحیح کار می کند و قابل خواندن است. اگر نگرانید که خیلی کند عمل می کند – که معمولا این طور نخواهد بود،‌ چرا که اکثر کدها آن قدر به تعداد بالا اجرا نمی شوند که زمان قابل توجهی بگیرند- می توانید بعد از اتمام، اندازه گیری کرده و در صورت نیاز بهبودش بدهید.

{{index "branching recursion"}}

نمی توان فرض کرد که همیشه روش استفاده از بازگشتی نسبت به حلقه، فاقد کارایی است. بعضی مسائل واقعا به روش بازگشتی بهتر و کاراتر حل می شوند. اکثر این مسائل مربوط به پیمایش و پردازش چندین شاخه که هر کدام ممکن است از شاخه‌های دیگر تشکیل شده باشند، می شوند.

{{id recursive_puzzle}}
{{index recursion, "number puzzle example"}}

به این معما توجه کنید: با شروع از عدد 1 و افزودن مکرر عدد 5 یا ضرب در عدد 3، بی نهایت عدد جدید می توان تولید کرد. چگونه می توانید تابعی بنویسید که عددی را گرفته و دنباله‌ای از ضرب و جمع‌هایی که منجر به تولید آن عدد شده است را برگرداند؟

به عنوان مثال، عدد 13 را می توان با یک ضرب در 3 و دوبار افزودن 5 بدست آورد در حالیکه عددی مثل 15 را اصلا نمی توان به این شیوه تولید کرد.

راه حل استفاده از روش بازگشتی:

```
function findSolution(target) {
  function find(current, history) {
    if (current == target) {
      return history;
    } else if (current > target) {
      return null;
    } else {
      return find(current + 5, `(${history} + 5)`) ||
             find(current * 3, `(${history} * 3)`);
    }
  }
  return find(1, "1");
}

console.log(findSolution(24));
// → (((1 * 3) + 5) * 3)
```

توجه داشته باشید که برنامه‌ی بالا لزوما _کوتاه‌ترین_ دنباله‌ی عملیات را پیدا نمی کند. هدف تابع فقط پیدا کردن هر دنباله‌ای از عملیات صحیح است.

اگر متوجه چگونگی کارکرد تابع بالا نشدید، نگران نباشید. بیایید با هم آن را بررسی کنیم چرا که تمرین بسیار خوبی برای تفکر بازگشتی است.

تابع درونی `find` عمل اصلی بازگشتی را انجام می دهد. دو آرگومان می گیرد که شامل عدد فعلی و رشته‌ای است که نحوه رسیدن به عدد را ضبط می کند. اگر راه حلی پیدا کرد ، رشته‌ای حاوی دنباله‌ی عملیات تا عدد مورد نظر را بر می گرداند. اگر راه حلی وجود نداشت، مقدار `null` را بر می گرداند.

{{index null, "|| operator", "short-circuit evaluation"}}

برای این کار، تابع یکی از این سه کار را انجام می دهد. اگر عدد فعلی عدد هدف بود، تاریخچه‌ی فعلی (history) به عنوان پاسخ برگردانده می شود. اگر عدد فعلی از عدد هدف بزرگتر بود، معنایی ندارد که کاوش بیشتری برای کشف تاریخچه انجام شود زیرا هر عمل جمع یا ضرب عدد را فقط بزرگتر می کند بنابراین مقدار `null` را برمی‌گرداند. در نهایت، اگر هنوز عدد فعلی از عدد هدف کوچکتر باشد، تابع هر دو مسیر ممکن که از عدد فعلی شروع می شود را آزمایش می کند و این کار را با دوبار فراخوانی خودش، یکبار برای جمع و یکبار برای ضرب انجام می دهد. اگر اولین فراخوانی چیزی به غیر از `null` را تولید کرد، آن را بر می گرداند. در غیر این صورت، فراخوانی دوم بازگردانده می شود – فارغ از اینکه رشته یا `null` را تولید کند.

{{index "call stack"}}

برای درک بهتر نحوه عملکرد تابع اجازه دهید به همه‌ی فراخوانی‌های `find` که برای پیدا کردن جواب مساله برای عدد 13 اتفاق می افتد نگاهی بیاندازیم.

```{lang: null}
find(1, "1")
  find(6, "(1 + 5)")
    find(11, "((1 + 5) + 5)")
      find(16, "(((1 + 5) + 5) + 5)")
        too big
      find(33, "(((1 + 5) + 5) * 3)")
        too big
    find(18, "((1 + 5) * 3)")
      too big
  find(3, "(1 * 3)")
    find(8, "((1 * 3) + 5)")
      find(13, "(((1 * 3) + 5) + 5)")
        found!
```

تورفتگی موجود در کد بالا برای نشان دادن عمق پشته‌ی فراخوانی توابع است. اولین بار که `find` فراخوانی می شود، خودش را برای کاوش راه حلی که با <bdo>`(1 + 5)`</bdo> شروع می شود فراخوانی می کند. این فراخوانی با استفاده بازگشت، تمامی راه حل هایی که عددی کمتر یا برابر عدد هدف را تولید می کند را مورد کاوش قرار می دهد. با توجه به این که این فراخوانی نمی تواند به راه حلی برسد مقدار `null` به عنوان خروجی فراخوانی اول بازگردانده می شود. عملگر `||` در اینجا باعث کاوش <bdo>`(1 * 3)`</bdo> می شود. این جستجو شانس بیشتری دارد به دلیل اینکه اول فراخوانی بازگشتی است که در دل یک فراخوانی بازگشتی دیگر قرار گرفته تا عدد هدف را تولید کند. درونی ترین فراخوانی بازگشتی یک رشته را بر می گرداند و هر کدام از عملگرهای `||` در فراخوانی‌های میانی آن رشته را دست به دست می کنند تا در نهایتا راه حل برگردانده شود.

## رشد توابع

{{index [function, definition]}}

دو روش دیگر به طور طبیعی باعث می شود که به سراغ استفاده از توابع در برنامه برویم.

{{index repetition}}

اول زمانی است که متوجه می شوید در حال تکرار کد بسیار مشابه‌ای در چندین جای برنامه هستید. ترجیح می دهیم از این کار اجتناب کنیم چراکه داشتن کد بیشتر به معنای فضای بیشتر برای پنهان شدن اشتباهات است و همچنین کار بیشتر برای افرادی که قصد دارند با خواندن کد برنامه را بفهمند. بنابراین قسمت تکراری  را گرفته و نام خوبی برای آن انتخاب می کنیم و آن را به تابع تبدیل می کنیم.

حالت دوم زمانی است که متوجه می شوید که به قابلیتی در برنامه نیاز دارید اما هنوز آن را کد نویسی نکرده اید که می تواند به عنوان یک تابع تعریف شود. در این صورت ابتدا نامی برای این تابع در نظر می گیرد و بعدا بنده‌ی آن را می نویسید. ممکن است حتی از تابع مورد نظر در دیگر کدها استفاده کنید قبل از اینکه خود تابع را تعریف کنید.

{{index [function, naming], [binding, naming]}}

سختی پیدا کردن یک نام خوب برای یک تابع نشانه خوبی است تا بفهمیم که مفهومی که قصد داریم به تابع تبدیلش کنیم چقدر برای ما شفاف و روشن است. اجازه بدهید تا مثالی را بررسی کنیم.

{{index "farm example"}}

قصد داریم تا برنامه‌ای بنویسیم که دو عدد را چاپ کند: تعداد گاو‌ها و مرغ‌های یک مزرعه به همراه کلمات `Cows` و `Chickens` بعد از آن ها و نشان دادن هر دو عددها با طول 3 رقم ( استفاده از 0 برای ترازبندی)

```{lang: null}
007 Cows
011 Chickens
```

با توجه به مساله به تابعی با دو آرگومان نیاز داریم. تعداد گاو‌ها و تعداد مرغ‌ها.

```
function printFarmInventory(cows, chickens) {
  let cowString = String(cows);
  while (cowString.length < 3) {
    cowString = "0" + cowString;
  }
  console.log(`${cowString} Cows`);
  let chickenString = String(chickens);
  while (chickenString.length < 3) {
    chickenString = "0" + chickenString;
  }
  console.log(`${chickenString} Chickens`);
}
printFarmInventory(7, 11);
```

{{index ["length property", "for string"], "while loop"}}

استفاده از <bdo>`.length`</bdo> بعد از مقدار رشته‌ای طول رشته را به ما می دهد. بنابراین، حلقه `while` عمل افزودن صفر به ابتدای رشته‌ی اعداد را تا زمانی که حداقل طول آن سه کاراکتر بشود ادامه می دهد.

ماموریت تمام است! اما درست زمانی که قرار است برنامه را برای کشاورز مثال‌مان ( به همراه صورت حساب) ارسال کنیم، با ما تماس می گیرد و اعلام می کند که اخیرا پرورش خوک را نیز شروع کرده است و آیا ما می توانیم قابلیت نرم افزار را افزایش داده تا تعداد خوک ها را نیز چاپ کند؟


{{index "copy-paste programming"}}

حتما می توانیم. اما درست وقتی که یک بار دیگر در حال کپی و الصاق آن چهار خط هستیم، کمی صبر کرده و تجدید نظر می کنیم. بایستی راه بهتری برای این کار وجود داشته باشد. اولین تلاش ما اینگونه است:

```
function printZeroPaddedWithLabel(number, label) {
  let numberString = String(number);
  while (numberString.length < 3) {
    numberString = "0" + numberString;
  }
  console.log(`${numberString} ${label}`);
}

function printFarmInventory(cows, chickens, pigs) {
  printZeroPaddedWithLabel(cows, "Cows");
  printZeroPaddedWithLabel(chickens, "Chickens");
  printZeroPaddedWithLabel(pigs, "Pigs");
}

printFarmInventory(7, 11, 3);
```

{{index [function, naming]}}

روش جدید به خوبی کار می کند. اما نام `printZeroPaddedWithLabel` کمی ناجور به نظر می رسد. به نظر می رسد که سه چیز مختلف – چاپ کردن(printing)، ترازکردن با صفر(zero-padding) و افزودن برچسب (adding a lable) – در یک تابع مخلوط شده است.

{{index "zeroPad function"}}

به جای به دوش کشیدن کل قسمت تکراری در یک تابع، اجازه دهید یک _مفهوم_ را انتخاب کنیم.

```
function zeroPad(number, width) {
  let string = String(number);
  while (string.length < width) {
    string = "0" + string;
  }
  return string;
}

function printFarmInventory(cows, chickens, pigs) {
  console.log(`${zeroPad(cows, 3)} Cows`);
  console.log(`${zeroPad(chickens, 3)} Chickens`);
  console.log(`${zeroPad(pigs, 3)} Pigs`);
}

printFarmInventory(7, 16, 3);
```

{{index readability, "pure function"}}

داشتن یک تابع با یک نام خوب و واضح مثل `zeroPad` کار را برای کسی که قصد دارد کد برنامه را بفهمد آسان تر خواهد کرد. همچنین می تواند در موقعیت‌های بیشتری مورد استفاده قرار گیرد تا اینکه مخصوص فقط این برنامه باشد. به عنوان مثال، می توانید از این تابع در چاپ جدولی از اعداد که به خوبی تراز شده اند استفاده کنید.

{{index [interface, design]}}

چقدر تابع‌مان می _باید_ هوشمند و جامع باشد بسازیم؟  می توانیم هر تابعی را بنویسیم ازتابعی که عمل بسیار ساده افزودن کاراکتر برای تراز عدد در سه کاراکتر را انجام می دهد تا یک سیستم پیچیده عمومی قالب‌بندی اعداد که قادر است اعداد اعشاری، منفی، ترازبندی نقطه‌ها، فاصله‌گذاری با کاراکترهای مختلف و غیره را مدیریت کند.

یه قاعده کاربردی در اینجا این است که هوشمندی بیشتری به تابع اضافه نکنیم  مگر در حالتی که قطعا مطمئن هستیم که از آن استفاده خواهیم کرد. ممکن است وسوسه شویم که برای هرعملکرد کوچکی که نیاز داریم ، چهارچوب‌هایی(framework) عمومی بنویسیم. در مقابل این وسوسه باید مقاومت کرد. در غیر این صورت برنامه جلو نخواهد رفت و در پایان کدهای بسیاری خواهید نوشت که هرگز استفاده نخواهید کرد.

{{id pure}}
## توابع و اثرات جانبی

{{index "side effect", "pure function", [function, purity]}}

به طور کلی می توان توابع را به آن‌هایی که برای اثرات جانبی‌شان فراخوانی می شوند و آن‌هایی که برای مقداری که برمی گردانند فراخوانی می شوند تقسیم کرد. (اگرچه قطعا می توان تابعی داشت که هم اثر جانبی داشته باشد و هم مقداری را بازگرداند).

{{index reuse}}

اولین تابع کمکی که در مثال مربوط به ((مثال مزرعه)) آمد، تابع `printZeroPaddedWithLabel` برای اثر جانبی‌اش فراخوانی شد: چاپ یک خط در خروجی. در نسخه‌ی دوم، تابع `zeroPad` برای مقداری که برمی‌گرداند  فراخوانده شد. اینکه تابع دوم در موقعیت های بیشتری نسبت به تابع اول کاربرد دارد تصادفی نیست. توابعی که مقادیری را ایجاد می کنند را راحتتر می توان به شکل های جدید ترکیب کرد نسبت به توابعی که مستقیما اثرات جانبی خاصی را اجرا می کنند.

{{index substitution}}

یک تابع _ناب_ (pure) شکل خاصی از یک تابعی است که مقداری را بر می گرداند و نه تنها خودش اثر جانبی ندارد، به اثرات جانبی دیگر کدها نیز وابستگی ندارد – مثلا متغیرهای جهانی که ممکن است در کدهای دیگر تغییر کنند را مورد استفاده قرار نمی دهد. یک تابع ناب ویژگی خوبش در این است که اگر با آرگومان‌های ثابت و مشابهی فراخوانی شود، همیشه مقدار مشابهی را برمیگرداند (و رفتار متفاوتی انجام نمی دهد). فراخوانی تابعی با این ویژگی را می توان بدون تغییر در معنای کد برنامه، معادل مقدار بازگشتی‌اش در نظر گرفت. زمانی که از صحت عملکرد یک تابع ناب مطمئن نیستید به راحتی می توانید با فراخوانی، آن را تست کنید و اگر در آن بستر (context) به درستی کار کرد، در همه‌ی بسترها هم به درستی کار خواهد کرد. توابع غیرناب اما برای آزمایش نیاز به شرایط و پیش‌نیازهای بیشتری دارند.

{{index optimization, "console.log"}}

البته نیازی نیست هنگامی که توابعی می نویسید که ناب نیستند احساس بدی داشته باشید یا اینکه برای حذف آن‌ها از کدهایتان جنگی راه بیاندازید. اثرات جانبی معمولا کاربرد خودشان را دارند.  مثلا هیچ راه نابی برای نوشتن نسخه‌ای از تابع `console.log` وجود ندارد و مشخص است که `console.log` بسیار مفید است. بعضی کارها را اگر به کمک اثرات جانبی انجام دهیم راحت تر و سریع‌تر می توان عملی کرد که در این صورت سرعت محاسبه‌ی برنامه را می توان دلیلی بر اجتناب از تابع ناب دانست.

## خلاصه

این فصل به شما نوشتن توابع خودتان را یاد داد. کلمه‌ی کلیدی `function` زمانی که به عنوان یک عبارت استفاده می شود، می تواند یک مقدار تابع ایجاد کنید. زمانی‌ هم که به عنوان یک دستور استفاده می شود، متغیری را اعلان می کند و تابعی را به عنوان مقدار آن به آن اختصاص می دهد. روش پیکانی نیز راهی دیگر برای ایجاد توابع است.

```
// Define f to hold a function value
const f = function(a) {
  console.log(a + 2);
};

// Declare g to be a function
function g(a, b) {
  return a * b * 3.5;
}

// A less verbose function value
let h = a => a % 3;
```

نقطه‌ی کلیدی در فهم توابع، درک مفهوم حوزه‌ها است. هر بلاک از کد حوزه‌ی جدیدی را ایجاد می کند.  پارامترها و متغیرهایی که درون یک بلاک اعلان می شوند نسبت به آن تابع محلی هستند، و از بیرون بلاک قابل دسترسی نیستند. متغیرهایی که با کلیدواژه‌ی `var` ایجاد می شوند به شکل متفاوتی عمل می کنند – محدوده‌ی آن تا پایان حوزه‌ی نزدیک ترین تابع یا فضای سراسری برنامه است.

جداسازی قابلیت‌های برنامه به شکل توابع متفاوت بسیار مفید است. باعث می شود که از تکرار بی مورد پرهیز کنید. همچنین توابع باعث می شوند که یک برنامه به وسیله گروهبندی کدها به قسمت‌هایی که هر کدام کار خاصی انجام می دهند، سازماندهی بشود.

## Exercises

### کمینه

{{index "Math object", "minimum (exercise)", "Math.min function", minimum}}

در [فصل قبل](program_structure#return_values) با تابع استاندارد `Math.min` که کوچکترین عدد را از بین آرگومان‌های ورودی برمی گرداند آشنا شدید. خودمان هم می توانیم این کار را برنامه نویسی کنیم. تابعی به نام `min` بنویسید که دو آرگومان دریافت کرده و کوچکترین آن‌ها را باز می‌گرداند.

{{if interactive

```{test: no}
// Your code here.

console.log(min(0, 10));
// → 0
console.log(min(0, -10));
// → -10
```
if}}

{{hint

{{index "minimum (exercise)"}}

If you have trouble putting braces and
parentheses in the right place to get a valid function definition,
start by copying one of the examples in this chapter and modifying it.

{{index "return keyword"}}

A function may contain multiple `return` statements.

hint}}

### بازگشت

{{index recursion, "isEven (exercise)", "even number"}}

قبلا دیده بودایم که عملگر `%` (باقی مانده) را می توان برای تشخیص زوج یا فرد بودن عدد استفاده کرد که برای این کار با <bdo>`% 2`</bdo> بخش پذیری بر دو مورد آزمایش قرار می گرفت. در اینجا با راهی دیگر برای تشخیص زوج یا فرد بودن یک عدد صحیح مثبت آشنا می شویم:

- صفر را زوج در نظر می گیریم

- یک فرد است

- برای هر عددی دیگر _N_ زوج بودن آن مشابه <bdo>_N_ - 2</bdo> خواهد بود.

تابع بازگشتی `isEven` را با توجه به توضیحات بالا تعریف کنید. تابع باید پارامتری مثبت و از جنس اعداد صحیح دریافت کند و مقداری از جنس بولی برگرداند.

{{index "stack overflow"}}

تابع را با مقادیر 50 و 75 تست کنید. بررسی کنید که اگر <bdo>-1</bdo> را به آن بدهید چه خواهد شد. چرا؟ آیا می توانید راهی برای حل مشکل پیش آمده پیدا کنید؟

{{if interactive

```{test: no}
// Your code here.

console.log(isEven(50));
// → true
console.log(isEven(75));
// → false
console.log(isEven(-1));
// → ??
```

if}}

{{hint

{{index "isEven (exercise)", ["if keyword", chaining], recursion}}

Your function will likely look somewhat similar to the inner `find`
function in the recursive `findSolution`
[example](functions#recursive_puzzle) in this chapter, with an
`if`/`else if`/`else` chain that tests which of the three cases
applies. The final `else`, corresponding to the third case, makes the
recursive call. Each of the branches should contain a `return`
statement or in some other way arrange for a specific value to be
returned.

{{index "stack overflow"}}

When given a negative number, the function will recurse again and
again, passing itself an ever more negative number, thus getting
further and further away from returning a result. It will eventually
run out of stack space and abort.

hint}}

### شمارش دانه

{{index "bean counting (exercise)", [string, indexing], "zero-based counting", ["length property", "for string"]}}

برای بدست آوردن کاراکتر یا حرف Nام یک رشته، می توانید از `"string"[N]` استفاده کنید. مقداری که برگردانده می شود رشته‌ای است که فقط یک کاراکتر دارد. (مثلا رشته‌ی `"b"`). کاراکتر اول در جایگاه صفرم قرار دارد. بنابراین آخرین کاراکتر در جایگاه <bdo>`string.length - 1`</bdo> قرار بگیرد. به عبارتی دیگر، یک رشته‌ی دو کاراکتری طولش 2 کاراکتر است و کاراکتر‌هایش در جایگاه 0 و 1 قرار دارند.

تابعی به نام `countBs` بنویسید که رشته ای را به عنوان تنها آرگومانش می پذیرد و عددی را برمیگرداند که نشان می دهد چند کاراکتر “B” بزرگ در رشته وجود دارد.

بعد، تابعی به نام `countChar` بنویسید که شبیه `countBs` کار می کند اما آرگومان دومی نیز دریافت می کند که مشخص کننده کاراکتری است که بایستی شمرده بشود ( به جای اینکه فقط B شمرده شود ). تابع `countBs` را بازنویسی کنید تا این ویژگی جدید را داشته باشد.

{{if interactive

```{test: no}
// Your code here.

console.log(countBs("BBC"));
// → 2
console.log(countChar("kakkerlak", "k"));
// → 4
```

if}}

{{hint

{{index "bean counting (exercise)", ["length property", "for string"], "counter variable"}}

Your function will need a ((loop)) that looks at every character in
the string. It can run an index from zero to one below its length (`<
string.length`). If the character at the current position is the same
as the one the function is looking for, it adds 1 to a counter
variable. Once the loop has finished, the counter can be returned.

{{index "local binding"}}

Take care to make all the bindings used in the function _local_ to the
function by properly declaring them with the `let` or `const` keyword.

hint}}
