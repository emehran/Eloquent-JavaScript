{{meta {load_files: ["code/scripts.js", "code/chapter/05_higher_order.js", "code/intro.js"], zip: "node/html"}}}

# توابع رده‌بالا (Higher-Order)

{{if interactive

{{quote {author: "استاد Yuan-Ma", title: "کتاب برنامه‌نویسی", chapter: true}

زو-لی و زو-سو داشتند درباره‌ی اندازه‌ی آخرین برنامه‌‌ی خود برای هم رجز می‌خواندند. زو-لی گفت: 'دویست هزار خط کد' بدون شمردن توضیحات! زو-سو پاسخ داد، هه! برنامه‌ی من تقریبا یک میلون خط شده! استاد Yuan-Ma گفت، 'بهترین برنامه‌ای که نوشتم پانصد خط کد داشت'. با شنیدن این جمله، زو-لی و زو-سو متنبه شدند و به خود آمدند.

quote}}

if}}

{{quote {author: "C.A.R. Hoare", title: "1980 ACM Turing Award Lecture", chapter: true}

{{index "Hoare, C.A.R."}}

دو روش برای ساختاردهی در طراحی نرم‌افزار وجود دارد: یک راه این است که آن را آن‌قدر ساده بسازیم که به وضوح مشخص باشد که ایرادی وجود ندارد، و روش دیگر این است که آن‌قدر آن را پیچیده بسازیم که نتوان  ایرادات نرم‌افزار را به وضوح تشخیص داد.

quote}}

{{figure {url: "img/chapter_picture_5.jpg", alt: "Letters from different scripts", chapter: true}}}

{{index "program size"}}

یک برنامه‌ی بزرگ پرهزینه است و این فقط به خاطر صرف زمان طولانی برای ساخت آن نیست بلکه پیچیدگی برنامه نیز همیشه بخشی از اندازه محسوب می‌شود؛ چیزی که برنامه‌نویسان را سردرگم کرده، به اشتباه‌ می‌اندازد و باعث می‌شود که برنامه خطا (_((باگ))_) داشته باشد. بنابراین یک برنامه‌ی بزرگ فضای زیادی برای پنهان شدن باگ‌ها فراهم می‌سازد و پیدا کردن باگ‌ها را سخت می‌کند.

{{index "summing example"}}

بیایید نگاه کوتاهی به نسخه‌ی نهایی دو برنامه‌ی مقدمه‌ی کتاب بی‌اندازیم. برنامه‌ی اول فاقد تابع و کلا دارای شش خط کد است:

```
let total = 0, count = 1;
while (count <= 10) {
  total += count;
  count += 1;
}
console.log(total);
```

دومین برنامه از دو تابع استفاده می‌کند و فقط یک خط دارد:


```
console.log(sum(range(1, 10)));
```

کدام یک بیشتر احتمال دارد باگ داشته باشد؟

{{index "program size"}}

اگر اندازه‌ی تعریف توابع `sum` و `range` را هم به حساب بیاوریم، برنامه دوم نیز برنامه‌ای بزرگ محسوب می‌شود – حتی بزرگ تر از برنامه اول. اما هنوز، من ادعا می کنم که این برنامه با احتمال بیشتری درست کار خواهد کرد.


{{index [abstraction, "with higher-order functions"], "domain-specific language"}}

با احتمال بیشتری درست کار خواهد کرد زیرا راه‌حل آن با ((واژگانی)) بیان شده است که با حل مسئله ارتباط معنایی دارند. جمع  بستن (sum) یک بازه‌ (range) از اعداد ربطی به حلقه‌ها و شمارنده‌ها ندارد؛ بلکه مربوط به بازه‌ها و عمل جمع می‌شود.

در تعریف این واژگان ( توابع `sum` و `range`) همچنان از حلقه‌ها، شمارنده‌ها و دیگر جزئیات فرعی استفاده خواهد شد. اما به دلیل اینکه آن‌ها به جای بیان برنامه به عنوان یک کل، مفاهیم ساده‌تری را نشان می‌دهند، آسان‌تر سامان می یابند.


## انتزاع

در فضای برنامه‌نویسی، این گونه واژگان را عموما انتزاع‌ها یا _((abstraction))s_ می گویند. انتزاع‌ها جزئیات را مخفی می کنند و به ما این امکان را می‌دهند که درباره‌ی مسئله‌ها در سطح بالاتری ( انتزاع بیشتر ) گفتگو کنیم.

{{index "recipe analogy", "pea soup"}}

به عنوان یک تشبیه، می‌توان این دو طرز تهیه‌ی سوپ نخود را با هم مقایسه کرد. اولین مورد به صورت زیر خواهد بود:

{{quote

یک فنجان نخود خشک برای هر نفر درون یک ظرف بریزید. به آن آب اضافه کنید تا همه‌ی نخود‌ها را در بر بگیرد. اجازه بدهید نخودها حداقل 12 ساعت در آب بمانند. بعد نخودها را از آب درآورده درون یک قابلمه قرار دهید.  برای هر نفر 4 لیوان آب اضافه کنید. روی قابلمه را پوشانده  و بگذارید برای 2 ساعت روی گاز باشد. برای هر نفر نیمی از پیاز را برداشته آن را تکه تکه کنید و به نخود‌ها اضافه نمایید. برای هر نفر یک ساقه‌ی کرفس بردارید. با چاقو قطعه قطعه کنید و به نخود ها اضافه کنید. برای هر نفر یک هویج در نظر گرفته، تکه تکه کرده با چاقو! و به نخودها اضافه کنید. بگذارید 10 دقیقه دیگر بپزد.

quote}}

طرز تهیه‌ی دوم:

{{quote

برای هر نفر: یک لیوان نخود خشک، نیمی از یک پیاز تکه تکه شده، یک ساقه کرفس، و یک هویج.

نخود ها را 12 ساعت بخیسانید. 2 ساعت در 4 لیوان آب ( برای یک نفر) روی گاز آهسته بجوشانید. سبزیجات را تکه تکه کرده و اضافه کنید. برای 10 دقیقه دیگر پخته شود.

quote}}

{{index vocabulary}}

دستور دوم کوتاه تر و توضیح ساده تری داشت. اما برای فهم آن باید چند واژه‌ی مرتبط با آشپزی را یاد داشته باشید – _خیساندن_،  _جوشاندن،_ _ریز ریز کردن_ و فکر کنم _سبزیجات_.

هنگام برنامه‌نویسی، نمی‌توانیم فرض کنیم همه‌ی واژگانی که نیاز داریم وجود داشته و در واژه‌نامه منتظر ما باشند. بنابراین، ممکن است به دام الگوی موجود در طرز تهیه‌ی اول بیفتیم - کارکردن روی قدم‌های دقیقی که کامپیوتر باید اجرا کند، یکی پس از دیگری، بدون توجه به مفاهیم سطح بالاتری که این دستورات بیان می کنند.

{{index abstraction}}

یکی از مهارت های کاربردی در برنامه‌نویسی، این است که زمانی که در سطح بسیار پایینی از انتزاع کار می‌کنید، نسبت به آن آگاه باشید.

## تکرار انتزاعی

{{index [array, iteration]}}

توابع ساده، مانند مواردی که تا کنون دیده ایم، برای ایجاد انتزاع مفید هستند. اما گاهی اوقات کافی نیستند.

{{index "for loop"}}

در برنامه‌ها رایج است که کاری را به تعداد مشخصی تکرار کنیم. می‌توان از یک حلقه‌ی `for` برای این کار استفاده کرد:

```
for (let i = 0; i < 10; i++) {
  console.log(i);
}
```
آیا می‌توان “انجام یک کار به تعداد _N_ بار” را با استفاده از یک تابع جدا کرد؟ خوب خیلی راحت می‌توان تابعی نوشت که <bdo>`console.log`</bdo> را _N_  بار فراخوانی کند.

```
function repeatLog(n) {
  for (let i = 0; i < n; i++) {
    console.log(i);
  }
}
```

{{index [function, "higher-order"], loop, [function, "as value"]}}

{{indexsee "higher-order function", "function, higher-order"}}

اما اگر بخواهیم کاری به غیر از چاپ اعداد در خروجی انجام دهیم چه؟ با توجه به این که “انجام یک کار” را می‌توان به عنوان یک تابع در نظر گرفت و توابع هم در واقع مقدار هستند، می‌توانیم "کار"مان را به عنوان یک مقدار تابع ارسال کنیم.


```{includeCode: "top_lines: 5"}
function repeat(n, action) {
  for (let i = 0; i < n; i++) {
    action(i);
  }
}

repeat(3, console.log);
// → 0
// → 1
// → 2
```

نیازی نیست که حتما یک تابع از پیش تعریف شده را به تابع `repeat`  ارسال کنید. اغلب آسان تر است که یک "مقدار تابع" همان موقع ایجاد کنیم.

```
let labels = [];
repeat(5, i => {
  labels.push(`Unit ${i + 1}`);
});
console.log(labels);
// → ["Unit 1", "Unit 2", "Unit 3", "Unit 4", "Unit 5"]
```

{{index "loop body", [braces, body], [parentheses, arguments]}}

این ساختار کمی شبیه حلقه‌ی `for` به نظر می‌رسد – ابتدا نوع حلقه را مشخص می‌کند سپس بدنه را فراهم می‌کند.  با این حال، بدنه اکنون به صورت یک مقدار تابع نوشته می‌شود، که خود درون پرانتز‌های مربوط به فراخوانی تابع `repeat` قرار گرفته است. به همین دلیل است که باید حتما به وسیله کروشه‌ی پایانی  _و_ پرانتز پایانی بسته شود.  در مواردی شبیه این مثال، جایی که بدنه، یک عبارت واحد کوچک است، می‌توانید کروشه‌ها را حذف کنید و حلقه را در یک خط بنویسید.

## توابع رده‌بالا - higher order

{{index [function, "higher-order"], [function, "as value"]}}

توابعی که روی توابع دیگر عمل می کنند، چه با گرفتن آن‌ها به عنوان آرگومان و چه با برگرداندن آن‌ها ، _توابع رده‌بالا_ نامیده می‌شوند. با توجه به این که پیش تر دیده‌ایم که توابع در واقع یک نوع مقدار هستند، مسئله‌ی قابل توجه و به خصوصی در مورد فلسفه‌ی وجود اینگونه توابع وجود ندارد. اصطلاح رده‌بالا (higher-order) از ((ریاضیات)) گرفته شده است جایی که به تمایز بین توابع و دیگر مقادیر اهمیت بیشتری داده شده است.

{{index abstraction}}

توابع رده‌بالا، به ما این امکان را می‌دهند که براساس _اقدام‌ها_، انتزاع ایجاد کنیم، نه فقط بر اساس مقدارها.  این گونه توابع با اشکال مختلفی می آیند. به عنوان نمونه‌، می‌توانید توابعی داشته باشید که خود توابعی را ایجاد می کنند.

```
function greaterThan(n) {
  return m => m > n;
}
let greaterThan10 = greaterThan(10);
console.log(greaterThan10(11));
// → true
```

یا توابعی داشته باشید که دیگر توابع را تغییر می‌دهند.


```
function noisy(f) {
  return (...args) => {
    console.log("calling with", args);
    let result = f(...args);
    console.log("called with", args, ", returned", result);
    return result;
  };
}
noisy(Math.min)(3, 2, 1);
// → calling with [3, 2, 1]
// → called with [3, 2, 1] , returned 1
```
حتی می‌توانید توابعی بنویسید که نوعی جدیدی از ((جریان کنترل)) را فراهم نمایند.

```
function unless(test, then) {
  if (!test) then();
}

repeat(3, n => {
  unless(n % 2 == 1, () => {
    console.log(n, "is even");
  });
});
// → 0 is even
// → 2 is even
```

{{index [array, methods], [array, iteration], "forEach method"}}

متد از پیش تعریف شده ای به نام `forEach` برای آرایه‌ها وجود دارد که کاری شبیه حلقه‌ی <bdo>`for`/`of`</bdo> را به عنوان یک تابع رده‌بالا انجام می دهد.

```
["A", "B"].forEach(l => console.log(l));
// → A
// → B
```

## مجموعه داده‌ی الفبا

یکی از جاهایی که در آن توابع رده‌بالا درخشان عمل می کنند، پردازش داده ها می‌باشد. برای پردازش داده ها، نیاز به داده‌ی واقعی داریم. در این فصل از ((مجموعه‌ی داده‌ای)) درباره‌ی حروف الفبا – ((سیستم های نوشتاری)) مانند لاتین، سیریلیک، یا عربی – استفاده می کنیم.

((یونیکد)) را از [فصل ?](values#unicode) به خاطر بیاورید، سیستمی که برای هر کاراکتر از زبان های نوشتاری، عددی را اختصاص می داد. اکثر این کاراکترها به الفبای مشخصی تعلق دارند.  این استاندارد دارای 140 الفبای متفاوت است – از این تعداد، 81 تای آن‌ها امروزه استفاده می‌شوند و 59 مورد دیگر به تاریخ پیوسته اند.

اگرچه من فقط می‌توانم کاراکترهای لاتین را به صورت روان بخوانم، اما این واقعیت که مردم جهان حداقل به 80 سیستم نوشتاری دیگر می نویسند که خیلی از آن‌ها را حتی نمی‌توانم تشخیص دهم را تحسین می کنم . به عنوان مثال، نمونه‌ی زیر دست نوشته ای از زبان ((تمیل)) است:


{{figure {url: "img/tamil.png", alt: "Tamil handwriting"}}}

{{index "SCRIPTS data set"}}

((مجموعه‌ داده‌ی)) نمونه‌ی ما حاوی اطلاعاتی از حدود 140 الفبای موجود در یونیکد است. این داده‌ها در قسمت [کدهای](https://eloquentjavascript.net/code#5) این فصل [
([_https://eloquentjavascript.net/code#5_](https://eloquentjavascript.net/code#5))]{if
book} به عنوان متغیر `SCRIPTS` قابل دانلود می‌باشند. این متغیر شامل آرایه‌ای از اشیاء است که هر کدام معرف یک الفبا می‌باشند.

```{lang: "application/json"}
{
  name: "Coptic",
  ranges: [[994, 1008], [11392, 11508], [11513, 11520]],
  direction: "ltr",
  year: -200,
  living: false,
  link: "https://en.wikipedia.org/wiki/Coptic_alphabet"
}
```

این اشیاء شامل نام الفبا، بازه‌ی یونیکدی که به آن اختصاص دارد،جهتی که به آن سمت نوشته می‌شود، منشاء زمانی (تقریبی)، اینکه اکنون نیز استفاده می‌شوند یا خیر، و لینکی به اطلاعات بیشتر می‌باشند. جهت نوشتن می‌تواند `"ltr"` برای چپ به راست، `"rtl"` راست به چپ (مانند عربی و عبری) یا `"ttb"` برای بالا به پایین (مانند زبان مغولی) باشد.

{{index "slice method"}}

خاصیت `ranges` شامل آرایه‌ای از بازه‌های کاراکتر یونیکد می‌باشد که هر کدام یک آرایه‌ی دو عنصری است که یک مرز پایین و بالا دارد. هر کد کاراکتری که در این بازه قرار بگیرد متعلق به الفبای مذکور است. مرز پایین، خود نیز شامل می‌شود ( کد 994 یک کاراکتر قبطی است) اما مرز بالایی، در الفبای مورد نظر قرار ندارد (کد 1008 متعلق به قبطی نیست)

## فیلتر کردن آرایه ها

{{index [array, methods], [array, filtering], "filter method", [function, "higher-order"], "predicate function"}}

برای پیدا کردن‌ الفباهایی که همچنان استفاده می‌شوند، تابع پیش رو می‌تواند مفید باشد. این تابع به عنوان یک صافی عمل می‌کند و عناصری که با شرط تطبیق ندارند را در نتایج نمی آورد.

```
function filter(array, test) {
  let passed = [];
  for (let element of array) {
    if (test(element)) {
      passed.push(element);
    }
  }
  return passed;
}

console.log(filter(SCRIPTS, script => script.living));
// → [{name: "Adlam", …}, …]
```

{{index [function, "as value"], [function, application]}}

تابع بالا از آرگومانی به نام `test` استفاده می‌کند، یک مقدار تابع، تا محاسبه مورد نظر را تکمیل کند – عمل انتخاب عناصری که باید به مجموعه اضافه شوند.

{{index "filter method", "pure function", "side effect"}}

توجه کنید که چگونه تابع `filter،` به جای اینکه عناصر را از آرایه حذف کند، آرایه‌ی جدیدی می سازد که شامل فقط عناصری است که با شرط تطبیق دارند .این تابع _ناب_ (pure) است. آرایه‌ای که دریافت می‌کند را تغییر نمی دهد.

شبیه `forEach،` تابع `filter` نیز یک متد ((استاندارد)) آرایه است. در مثالا بالا، تابع تعریف شد تا شیوه‌ی کارکرد درون آن را نشان دهد. از حالا به بعد، به شکل زیر از آن استفاده خواهیم کرد:

```
console.log(SCRIPTS.filter(s => s.direction == "ttb"));
// → [{name: "Mongolian", …}, …]
```

{{id map}}

## تغییر شکل به وسیله‌ی map


{{index [array, methods], "map method"}}

فرض کنید آرایه ای از اشیاء در دست داریم که نمایانگر الفبایی است که پس از اعمال فیلتر به آرایه‌ی `SCRIPTS` به وجود آمده است. اما اگر آرایه‌ای از نام ها در اختیار داشتیم کارمان ساده تر می شد.

{{index [function, "higher-order"]}}

متد `map` برای تغییر یک آرایه استفاده می‌شود. به این صورت که تابعی را به همه‌ی عناصر آرایه اعمال کرده و آرایه‌ی جدیدی را از مقادیر برگردانده شده می سازد. تعداد عناصر آرایه‌ی جدید با آرایه‌ی ورودی برابر است. اما محتوای آن به وسیله‌ی تابع داده شده تغییر می‌کند.

```
function map(array, transform) {
  let mapped = [];
  for (let element of array) {
    mapped.push(transform(element));
  }
  return mapped;
}

let rtlScripts = SCRIPTS.filter(s => s.direction == "rtl");
console.log(map(rtlScripts, s => s.name));
// → ["Adlam", "Arabic", "Imperial Aramaic", …]
```

شبیه `forEach` و `filter` متد `map` نیز از متدهای استاندارد آرایه است.

## خلاصه‌ کردن یک آرایه به وسیله‌ی متد reduce

{{index [array, methods], "summing example", "reduce method"}}

یکی دیگر از کارهای رایجی که با آرایه‌ها انجام می‌شود، محاسبه‌ی یک مقدار واحد از آن‌ها است. مثال تکراری خودمان، جمع کردن مجموعه‌ای از اعداد، نمونه‌ی از آن است. یک مثال دیگر می‌تواند پیدا کردن الفبایی با بیشترین حروف باشد.

{{indexsee "fold", "reduce method"}}

{{index [function, "higher-order"], "reduce method"}}

عمل "رده‌بالا"یی که برای این الگو وجود دارد، _reduce_ (کاهش) خوانده می‌شود ( گاهی اوقات هم آن‌ را _تاکردن_ می نامند.) این متد به صورت مکرر عنصری از آرایه را گرفته و آن را با مقدار قبلی ترکیب کرده و در نهایت یک مقدار واحد تولید می‌کند. زمانی که اعداد را جمع می‌کنید، ابتدا با عدد صفر شروع می‌کنید و بعد یکایک عناصر را به مجموع اضافه می‌کنید.

پارامترهای تابع `reduce،` بدون در نظر گرفتن خود آرایه، شامل یک تابع ترکیب و یک مقدار اولیه می‌باشند. مفهوم این تابع به سرراستی `filter` و `map` نیست، پس بیایید نگاه دقیق تری بکنیم:

```
function reduce(array, combine, start) {
  let current = start;
  for (let element of array) {
    current = combine(current, element);
  }
  return current;
}

console.log(reduce([1, 2, 3, 4], (a, b) => a + b, 0));
// → 10
```

{{index "reduce method", "SCRIPTS data set"}}

متد استاندارد آرایه‌ی `reduce` که شبیه به تابع بالا می‌باشد، یک مزیت بیشتر نیز دارد. اگر آرایه‌ی شما حداقل یک عنصر داشته باشد، می‌توانید آرگومان `start` را حذف کنید. خود تابع، اولین عنصر آرایه را به عنوان مقدار شروع در نظر گرفته و عمل کاهش را از عنصر دوم شروع می‌کند.

```
console.log([1, 2, 3, 4].reduce((a, b) => a + b));
// → 10
```

{{index maximum, "characterCount function"}}

برای استفاده از متد `reduce` (دو بار) برای پیدا کردن الفبایی که بیشترین حروف را دارد، می‌توانیم چیزی مثل کد پایین بنویسیم:

```
function characterCount(script) {
  return script.ranges.reduce((count, [from, to]) => {
    return count + (to - from);
  }, 0);
}

console.log(SCRIPTS.reduce((a, b) => {
  return characterCount(a) < characterCount(b) ? b : a;
}));
// → {name: "Han", …}
```

تابع `characterCount` بازه‌ های  مربوط به یک الفبا را به وسیله جمع کردن اندازه‌ی آن‌ها کاهش می دهد. به استفاده از “تجزیه” (destructing) در لیست پارامتر ها در تابع کاهش دهنده توجه کنید. در فراخوانی دوم تابع `reduce`، از این نتیجه برای پیدا کردن بزرگترین الفبا استفاده می‌شود؛  دو به دو الفبا ها را مقایسه کرده و الفبای بزرگتر را بر می گرداند.


الفبای Han (هان) دارای بیش از <bdo>89,000</bdo> کاراکتر در استاندارد یونیکد است، که باعث شده به عنوان بزرگ‌ترین سیستم نوشتاری در این مجموعه شناخته شود. هان الفبایی است که (گاهی) برای متون چینی، ژاپنی، و کره‌ای استفاده می‌شود. این زبان‌ها کاراکترهای مشترک زیادی دارند اگرچه که به شکل متفاوتی آن‌ها را می نویسند. کنسرسیوم یونیکد ( مستقر در ایالات متحده) تصمیم گرفت که آن‌ها را به عنوان یک سیستم نوشتاری واحد در نظر بگیرد تا کدهای کاراکتر کمتری استفاده شود. این کار _یکی سازی الفبای هان_ خوانده می‌شود که هنوز بعضی افراد را خیلی عصبانی می‌کند.

## ترکیب پذیری
{{index loop, maximum}}

ملاحظه کنید چگونه بدون استفاده توابع‌ رده‌بالا، می‌توانستیم مثال قبل را بنویسیم ( پیدا کردن بزرگ‌ترین الفبا).  آن‌قدرها هم بد از کار در نمی آمد.

```{test: no}
let biggest = null;
for (let script of SCRIPTS) {
  if (biggest == null ||
      characterCount(biggest) < characterCount(script)) {
    biggest = script;
  }
}
console.log(biggest);
// → {name: "Han", …}
```

با چند متغیر اضافی و چهار خط کدنویسی بیشتر، همچنان برنامه خوانایی خوبی دارد.

{{index "average function", composability, [function, "higher-order"], "filter method", "map method", "reduce method"}}

{{id average_function}}

توابع رده‌بالا زمانی شروع به درخشش می کنند که نیاز باشد عملیات را _ترکیب_ کنید. به عنوان یک مثال، بیایید کدی بنویسیم که میانگین سال ایجاد را برای الفبا‌های زنده و از رده خارج پیدا می‌کند.

```
function average(array) {
  return array.reduce((a, b) => a + b) / array.length;
}

console.log(Math.round(average(
  SCRIPTS.filter(s => s.living).map(s => s.year))));
// → 1188
console.log(Math.round(average(
  SCRIPTS.filter(s => !s.living).map(s => s.year))));
// → 188
```

بنابراین به طور میانگین الفباهای از رده خارج در یونیکد، قدیمی تر از موارد زنده هستند. این نتیجه خیلی معنای خاصی نمی دهد یا آمار شگفت انگیزی محسوب نمی‌شود. اما امیدوارم  با من هم‌نظر باشید که کدی که برای محاسبه‌ی این نتیجه استفاده شده از خوانایی خوبی برخوردار است. می‌توانید آن را به عنوان یک خط لوله در نظر بگیرید:  با همه‌ی الفباها شروع می کنیم، موارد زنده (یا از رده خارج) را فیلتر می کنیم، سال‌ها را از آن‌ها گرفته، میانگین می گیریم و نتیجه را گرد می کنیم.

قطعا می شد این محاسبه را به وسیله یک ((حلقه‌ی)) بزرگ پیاده‌سازی کرد.

```
let total = 0, count = 0;
for (let script of SCRIPTS) {
  if (script.living) {
    total += script.year;
    count += 1;
  }
}
console.log(Math.round(total / count));
// → 1188
```

اما کاری که می‌کند و چگونگی آن به راحتی قابل درک نیست. و به علت اینکه نتایج میانی به عنوان مقادیری مربوط و منسجم نشان داده نمی‌شوند، برای اینکه بتوان چیزی شبیه به `average` را به عنوان یک تابع مستقل از دل آن استخراج کرد، کار زیادی خواهد برد.

{{index efficiency, [array, creation]}}

با توجه به کاری که کامپیوتر در واقعیت انجام می دهد، این دو رهیافت نسبتا با هم متفاوت هستند. در مورد اول، یک آرایه جدید پس از اجرای `filter` و `map` ایجاد می‌شود، در حالیکه در مورد دوم فقط محاسباتی روی اعداد انجام می‌شود و کار کمتری صورت می‌گیرد. معمولا استفاده از روش خواناتر، قابل استفاده و منطقی‌ است اما اگر قصد پردازش آرایه‌های خیلی بزرگ را دارید، و این کار را به تعداد دفعات بالایی انجام می دهید، استفاده از روشی با خوانایی و انتزاع کمتر، ارزش سرعتی که دریافت می‌کنید را دارد.

## رشته‌ها و کدهای کاراکتر

{{index "SCRIPTS data set"}}

یکی از کاربرد‌هایی که می‌توان برای این مجموعه‌ی داده در نظر گرفت، استفاده از آن برای تشخیص الفبای یک متن است. بیایید به سراغ برنامه‌ای برویم که همین کار را انجام می دهد.

به خاطر دارید که هر الفبا حاوی یک آرایه از بازه‌های کد کاراکتری که به آن اختصاص داشت بود. با داشتن یک کد کاراکتر، می‌توانیم از تابعی مثل زیر برای پیدا کردن الفبای مرتبطش ( در صورت وجود )‌ استفاده کنیم:

{{index "some method", "predicate function", [array, methods]}}

```{includeCode: strip_log}
function characterScript(code) {
  for (let script of SCRIPTS) {
    if (script.ranges.some(([from, to]) => {
      return code >= from && code < to;
    })) {
      return script;
    }
  }
  return null;
}

console.log(characterScript(121));
// → {name: "Latin", …}
```

متد `some` یکی دیگر از توابع رده‌بالا است. این متد تابعی را به عنوان شرط دریافت می‌کند. این شرط به تک تک عناصر آرایه اعمال شده و اگر حداقل برای یکی از آن‌ها صدق کند (true باشد)، تابع نیز true را بر می گرداند.

{{id code_units}}

اما چگونه می‌توانیم کدهای کاراکتر یک رشته را بدست بیاوریم؟

در [فصل ?](values) اشاره کردم که در جاوااسکریپت ((رشته‌ها)) به عنوان دنباله‌ای از اعداد 16 بیتی کدگذاری می‌شوند که به آن‌ها ((واحد‌های کد)) گفته می‌شود. ابتدا قرار بود در ((یونیکد)) هر کد ((کاراکتر)) در یکی از این واحد‌ها قرار گیرد ( که چیزی بیش از <bdo>65,000</bdo> کاراکتر را در اختیار شما می گذارد).  زمانی که روشن شد این مقدار کافی نیست، خیلی ها از موضوع اختصاص حافظه‌ی بیشتر برای هر کاراکتر طفره می رفتند. برای حل این مشکل، ((UTF-16)) اختراع شد ، فرمتی که برای رشته‌های جاوااسکریپت استفاده می‌شود.  این سیستم اکثر کاراکترهای رایج را با یک واحد کد 16 بیتی توصیف می‌کند اما برای دیگر کدها، از ((دو واحد)) استفاده می‌کند.

{{index error}}

این‌ روزها UTF-16  عموما به عنوان ایده‌ی بدی شناخته می‌شود. به نظر می‌رسد که عمدا طوری طراحی شده است که اشتباه ساز باشد. به سادگی می‌توان برنامه‌هایی نوشت که در ظاهر تفاوتی بین واحدها و کاراکترهای کد قائل نمی‌شوند و بدون مشکل هم کار می کنند. اما به محض اینکه کسی سعی کند از این گونه برنامه‌ها برای نوشتن بعضی ((کاراکترهای چینی)) نامتداول استفاده کند، برنامه از کار می افتد. خوشبختانه، با ظهور ((ایموجی))، همه به سراغ استفاده از کاراکترهای دو واحده رفته اند، و مسئولیت سروکار داشتن با این گونه مشکلات با عدالت بیشتری توزیع شده است.

{{index [string, length], [string, indexing], "charCodeAt method"}}

متاسفانه، در جاوااسکریپت کارهای واضح روی رشته‌ها، مثل گرفتن طول آن‌ها به وسیله خاصیت `length` و دسترسی به محتوای آن‌ها به وسیله براکت ها، تنها از واحدهای کد پشتیبانی می‌کند.

```{test: no}
// Two emoji characters, horse and shoe
let horseShoe = "🐴👟";
console.log(horseShoe.length);
// → 4
console.log(horseShoe[0]);
// → (Invalid half-character)
console.log(horseShoe.charCodeAt(0));
// → 55357 (Code of the half-character)
console.log(horseShoe.codePointAt(0));
// → 128052 (Actual code for horse emoji)
```

{{index "codePointAt method"}}

متد `charCodeAt` در جاوااسکریپت به شما یک واحد کد تحویل می دهد نه کد یک کاراکتر کامل. متد `codePointAt،` که بعدا اضافه شد، کد کامل یونیکد کاراکتر را برمی گرداند. بنابراین می‌توانیم از این متد برای گرفتن کاراکترهای یک رشته استفاده کنیم. اما آرگومانی که به متد `codePointAt` ارسال می‌شود هنوز یک اندیس گرفته‌ شده از دنباله‌ی کدهای واحد است. پس با توجه به آن، برای پیمایش همه‌ی کاراکتر‌های یک رشته، همچنان باید بدانیم که هر کاراکتر یک واحد یا دو واحد کد اشغال کرده است.

{{index "for/of loop", character}}

در [فصل پیش](data#for_of_loop)، اشاره کردم که حلقه‌ی <bdo>`for`/`of`</bdo>  را همچنین می‌توان برای رشته‌ها استفاده کرد. شبیه `codePointAt`، این نوع از حلقه نیز زمانی معرفی شد که همه از مشکلات UTF-16 آگاه بودند. با استفاده از آن برای پیمایش یک رشته، به جای کدهای واحد، کاراکترهای واقعی برگردانده می‌شوند.

```
let roseDragon = "🌹🐉";
for (let char of roseDragon) {
  console.log(char);
}
// → 🌹
// → 🐉
```

اگر کاراکتری دارید ( که رشته‌ای از یک یا دو واحد کد است)، می‌توانید از متد <bdo>`codePointAt(0)`</bdo> برای گرفتن کد متناظرش استفاده کنید.

## تشخیص متن

{{index "SCRIPTS data set", "countBy function", [array, counting]}}

تا اینجا یک تابع به نام `characterScript` به همراه روشی برای پیمایش کاراکترها در اختیار داریم. گام بعدی شمردن کاراکترهایی است که به هر الفبا مربوط می‌شود. می‌توان از تابع زیر برای این کار استفاده کرد:

```{includeCode: strip_log}
function countBy(items, groupName) {
  let counts = [];
  for (let item of items) {
    let name = groupName(item);
    let known = counts.findIndex(c => c.name == name);
    if (known == -1) {
      counts.push({name, count: 1});
    } else {
      counts[known].count++;
    }
  }
  return counts;
}

console.log(countBy([1, 2, 3, 4, 5], n => n > 2));
// → [{name: false, count: 2}, {name: true, count: 3}]
```

تابع `countBy` به عنوان آرگومان، یک مجموعه (هرچیزی که بتوان به وسیله‌ی <bdo>`for`/`of`</bdo> آن را پیمایش کرد) به همراه تابعی برای گروه‌بندی دریافت می‌کند. خروجی این تابع، آرایه‌ای از اشیاء است که هر یک معرف یک گروه است و به شما می گوید چه تعداد عنصر در آن گروه پیدا شده است.

{{index "findIndex method", "indexOf method"}}

این تابع خود از متدی دیگر به نام `findIndex` استفاده می‌کند. این متد به شکلی شبیه به `indexOf` عمل می‌کند، اما به جای گشتن برای یک مقدار خاص، به دنبال اولین مقداری می گردد که تابع داده شده، با آن مقدار true را برمی گرداند. مانند `indexOf،` اگر عنصری با آن شرایط پیدا نشود، <bdo>-1</bdo> برگردانده می‌شود.

{{index "textScripts function", "Chinese characters"}}

با استفاده از countBy می‌توانیم تابعی بنویسیم که الفبای یک متن را برای ما مشخص کند.

```{includeCode: strip_log, startCode: true}
function textScripts(text) {
  let scripts = countBy(text, char => {
    let script = characterScript(char.codePointAt(0));
    return script ? script.name : "none";
  }).filter(({name}) => name != "none");

  let total = scripts.reduce((n, {count}) => n + count, 0);
  if (total == 0) return "No scripts found";

  return scripts.map(({name, count}) => {
    return `${Math.round(count * 100 / total)}% ${name}`;
  }).join(", ");
}

console.log(textScripts('英国的狗说"woof", 俄罗斯的狗说"тяв"'));
// → 61% Han, 22% Latin, 17% Cyrillic
```

{{index "characterScript function", "filter method"}}

تابع بالا ابتدا تعداد کاراکتر‌ها را با نام می شمارد، با استفاده از `characterScript` به آن‌ها نامی را اختصاص می دهد، و برای کاراکترهایی که جزء هیچ الفبایی محسوب نمی‌شوند، مقدار `“none”` را به رشته باز می گرداند. تابع `filter` تمامی `“none”` ها را از آرایه‌ی نتیجه حذف می‌کند، چرا که علاقه ای به این کاراکتر‌ها نداریم.

{{index "reduce method", "map method", "join method", [array, methods]}}

برای اینکه بتوانیم ((درصد‌ها)) را محاسبه کنیم، ابتدا به تعداد همه‌ی کاراکترهایی که به یک الفبا تعلق دارند نیاز داریم، که می‌توانیم این کار را با `reduce` انجام دهیم. اگر این کاراکترها پیدا نشدند، تابع، یک رشته‌ی مشخص برمی گرداند. در غیر این صورت به وسیله تابع `map` موارد محاسبه‌شده را به رشته‌هایی مناسب خواندن تبدیل می‌کند و در آخر به وسیله `join` آن‌ها را به هم الحاق می نماید.

## خلاصه

یکی از جنبه‌های عمیقا کاربردی جاوااسکریپت، امکان ارسال مقدارهای تابع به دیگر توابع است. با این ویژگی می‌توان توابعی برای مدل‌سازی محاسباتی نوشت که دارای بخشی "باز" می‌باشند. کدی که این توابع را فراخوانی می‌کند، می‌تواند این فضای باز را به وسیله‌ی مقدار‌های تابع تکمیل کند.

آرایه‌ها مجموعه‌ی مفیدی از توابع رده‌بالا را فراهم می سازند. می‌توانید از `forEach` برای پیمایش عناصر یک آرایه استفاده کنید. برای برگرداندن یک آرایه‌ی جدید با عناصری که شرایط خاصی دارند، متد `filter` مفید است. برای تغییر شکل عناصر یک آرایه به وسیله‌ی یک تابع، می‌توانید از `map` استفاده کنید. `reduce` برای ترکیب همه‌ی عناصر یک آرایه و ساخت یک مقدار واحد، کاربرد دارد. متد `some` بررسی می‌کند که آیا حداقل یک عنصر در آرایه با شرط تابع ورودی تطبیق می‌کند  و `findIndex` موقعیت اولین عنصری که با شرط ارسالی تطبیق دارد را بر می گرداند.

## تمرین‌ها

### یک‌سطح کردن آرایه

{{index "flattening (exercise)", "reduce method", "concat method", [array, flattening]}}

با استفاده از متد `reduce` و ترکیب آن با `concat،` آرایه‌ای از آرایه‌ها را گرفته و آرایه‌ی تختی (مسطح) بسازید که شامل همه‌ی عناصر آرایه‌های اصلی باشد.

{{if interactive

```{test: no}
let arrays = [[1, 2, 3], [4, 5], [6]];
// Your code here.
// → [1, 2, 3, 4, 5, 6]
```
if}}

### شبیه‌سازی حلقه

{{index "your own loop (example)", "for loop"}}

تابع رده‌بالایی به نام `loop` بنویسید که کاری مشابه یک حلقه‌ی `for` انجام دهد. این تابع به عنوان آرگومان، یک مقدار، تابع شرط، تابع به‌روز‌رسانی و بدنه‌ی یک تابع را دریافت می‌کند. در هر تکرار، ابتدا، تابع شرط را بر روی مقدار فعلی حلقه اجرا می‌کند و در صورتی که false را تولید کرد متوقف می‌شود. سپس بدنه تابع ارسالی را با دادن مقدار فعلی به آن، اجرا می نماید. در نهایت برای ایجاد یک مقدار جدید، تابع به‌روزرسانی را فراخوانی کرده و از ابتدا شروع می‌کند.

هنگام تعریف تابع، می‌توانید از یک حلقه‌ی معمولی برای پیاده‌سازی حلقه‌ی اصلی استفاده کنید.

{{if interactive

```{test: no}
// Your code here.

loop(3, n => n > 0, n => n - 1, console.log);
// → 3
// → 2
// → 1
```

if}}

### همه‌چیز

{{index "predicate function", "everything (exercise)", "every method", "some method", [array, methods], "&& operator", "|| operator"}}

مشابه متد `some،` آرایه‌ها متدی به نام `every` نیز دارند. این متد زمانی `true` برمی گرداند که تابع داده شد برای _همه‌ی_ عناصر آرایه، مقدار `true` را تولید کند. به نوعی، `some` نسخه‌ای از عملگر `||` است که روی آرایه‌ها عمل می‌کند و `every` شبیه به عملگر `&&` کار می‌کند.

متد `every` را به عنوان یک تابع پیاده سازی کنید که یک آرایه و یک تابع دریافت می‌کند. دو نسخه‌ از این تابع را بنویسید، یک نسخه با استفاده از حلقه و دیگری با استفاده از متد `some`.

{{if interactive

```{test: no}
function every(array, test) {
  // Your code here.
}

console.log(every([1, 3, 5], n => n < 10));
// → true
console.log(every([2, 4, 16], n => n < 10));
// → false
console.log(every([], n => n < 10));
// → true
```

if}}

{{hint

{{index "everything (exercise)", "short-circuit evaluation", "return keyword"}}

مانند عملگر `&&`، متد `every` به محض اینکه به موردی برخورد کند که با شرط تطبیق ندارد، ارزیابی دیگر عناصر را متوقف می‌کند. بنابراین در نسخه‌ی مبتنی بر حلقه، می‌توان با مشاهده‌ی خروجی false تابع روی یک عنصر، از حلقه به وسیله‌ی `break` یا `return` خارج شد. اگر حلقه بدون برخورد با چنین عنصری به انتهای خود برسد، می دانیم که همه‌ی عناصر مطابق تابع شرط بوده اند و می‌توانیم true را برگردانیم.

برای ساخت `every‍‍` با استفاده از `some`، می‌توانیم از قوانین _((دمورگان))_ استفاده کنیم، که براساس آن‌، <bdo>`a && b`</bdo> برابر است با <bdo>`!(!a || !b)`</bdo>. می‌توان آن را به آرایه‌ها تعمیم داد به این صورت که همه‌ی عناصر در آرایه با شرط تطبیق خواهند داشت اگر عنصری در آرایه نباشد که تطبیق نداشته باشد.

hint}}

### جهت نوشتن غالب

{{index "SCRIPTS data set", "direction (writing)", "groupBy function", "dominant direction (exercise)"}}

تابعی بنویسید که بتواند جهت نوشتن غالب یک متن را محاسبه کند. به یاد دارید که هر شیء الفبا خاصیتی به نام `direction` دارد که می‌تواند `“ltr”` (چپ به راست)، `“rtl”` (راست به چپ)، یا  `“ttb”` (بالا به پایین) باشد.

{{index "characterScript function", "countBy function"}}

جهت نوشتاری غالب، جهتی است که بیشتر کاراکترهایی که الفبای مشخصی دارند، در آن جهت نوشته می‌شوند. احتمالا دو تابع `characterScript` و `countBy` که پیش تر نوشته شده اند، اینجا کاربرد خواهند داشت.

{{if interactive

```{test: no}
function dominantDirection(text) {
  // Your code here.
}

console.log(dominantDirection("Hello!"));
// → ltr
console.log(dominantDirection("Hey, مساء الخير"));
// → rtl
```
if}}

{{hint

{{index "dominant direction (exercise)", "textScripts function", "filter method", "characterScript function"}}

پاسخ شما ممکن است شباهت زیادی به نیمه‌ی اول مثال `textScripts` داشته باشد. دوباره باید کاراکترها را با شرطی براساس `characterScript` بشمارید و سپس بخشی از نتیجه که الفبای مشخصی ندارند را فیلتر کنید.

{{index "reduce method"}}

پیدا کردن جهت نوشته بر اساس شمارش بیشترین کاراکتر را می‌توان با متد `reduce` انجام داد. اگر راه حل به ذهن‌تان نرسید، به مثالی که پیش‌تر در این فصل در مورد استفاده از `reduce` برای پیدا کردن الفبایی با بیشترین حروف مراجعه کنید.

hint}}
